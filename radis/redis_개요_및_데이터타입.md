# 작성일

- 2025-11-23

# 1. Redis란?

Redis는 캐시라고 알려져 있기도 하지만 NoSQL 데이터베이스 이며 메세지 브로커로 사용되기도 하는 데이터 구조 서버(Data Structure Server) 이다.

## Redis가 빠른 이유

레디스는 인-메모리 캐시이므로 요청이 들어올 시 캐시에서 데이터를 찾는다.
`Key-Value` 형태로 데이터를 인메모리 데이터 저장소(RAM 메모리)에 저장함으로써 Disk Overhead 가 없다. 때문에 디스크 I/O를 거치는 여타 RDBMS에 비해 빠른 데이터 접근이 가능하다.

## 일반적으로 사용하는 구조

서버 -> Redis -> RDBMS 와 같은 구조가 있고 서버는 데이터 요청이 들어오면 Redis 메모리를 확인해 데이터가 있는지 확인하고 데이터가 없을시 캐시미스가 발생하면 이후 RDBMS를 조회해서 데이터를 가져온다.

때문에 일반적인 RDBMS만 가지고 있는 서버에 비해 빠르다는 장점이 있다.

## 디스크에 저장 가능한 인-메모리 데이터베이스

- Redis는 기본적으로 인-메모리 데이터 구조 저장소 이기 때문에 서버가 종료되면 데이터는 휘발된다.
  - 하지만 비휘발성 데이터 저장 기능을 지원하기 때문에 Redis Database와 Append Only File과 같이 두 가지 형태로 영구 저장이 가능하다.
- 또한 캐시 TTL을 정해 특정 시간이 만료되면 사용되지 않는 값들을 제거할 수 있으므로 효과적으로 관리할 수 있다.

# 2. Not Only SQL 자료구조 특징

Not Only SQL 이라는 의미를 가지는 데이터베이스로 RDBMS가 아닌 다른 형테로 데이터베이스를 운영하기 때문에 NoSQL 별로 다른 자료구조를 갖는다.

## Redis 데이터 자료구조

- ‘키-값(Key-Value)’ 형태로 데이터를 저장하는 Redis 내에서는 ‘키(key)’는 문자열 형태로 고정되어 있지만, ‘값(Value)’는 Strings, Bitmaps, Bit field, Hashes, Lists, Sets, Sorted Sets, Geospatial Indexes, Hyperloglogs, Streams 형태로 다양한 데이터 저장이 가능하다.

### 핵심 자료 구조

- String
- List
- Hash
- Set
- Sorted Set

#### String

| 항목          | 내용                                                                       |
| ------------- | -------------------------------------------------------------------------- |
| 개념          | 가장 기본 타입. 텍스트, 숫자, 바이너리 블랍 모두 가능                      |
| 대표 명령     | `SET`, `GET`, `INCR`(기존값 대비 증가), `DECR`(기존값 대비 차감), `APPEND` |
| 전통 자료구조 | "값 하나" (문자열/숫자)                                                    |
| 활용          | 캐시(토큰, 세션), 카운터, 플래그, 설정 값 등                               |

#### Bitmap

> Redis에서 Bitmap은 별도의 타입이 아닌 String에 비트 연산을 하는 방식이다.

| 항목          | 내용                                                                                  |
| ------------- | ------------------------------------------------------------------------------------- |
| 개념          | String을 “비트 배열(bit array)”로 보고 각 비트에 0/1 저장                             |
| 대표 명령     | SETBIT, GETBIT, BITCOUNT, BITOP                                                       |
| 전통 자료구조 | Bitset / 비트 배열                                                                    |
| 활용 예       | 출석체크(일자별 비트), feature flag 집합, 매우 큰 boolean 배열을 메모리 절약해서 표현 |

#### Bitfield

역시 String 기반인데, 단일 비트가 아니라 여러 비트를 묶어서 정수 필드처럼 다루는 기능.

| 항목          | 내용                                                              |
| ------------- | ----------------------------------------------------------------- |
| 개념          | 하나의 String을 여러 “비트 필드”로 쪼개서 각각을 정수처럼 읽고 씀 |
| 대표 명령     | BITFIELD                                                          |
| 전통 자료구조 | Packed struct / 비트필드                                          |
| 활용 예       | 여러 개의 작은 카운터나 상태 값을 하나의 키에 압축 저장           |

예:

0~7비트: 상태코드, 8~15비트: 점수, … 이런 식으로 한 String에 packed 저장

#### Hash

| 항목          | 내용                                                                      |
| ------------- | ------------------------------------------------------------------------- |
| 개념          | key 안에 또다른 필드-값(field-value) 쌍을 여러 개 저장 (작은 객체를 표현) |
| 대표 명령     | HSET, HGET, HGETALL, HDEL                                                 |
| 전통 자료구조 | HashMap / 객체(Object)                                                    |
| 활용 예       | 사용자 프로필, 설정 객체, JSON 비슷한 구조 (단, 중첩은 안 됨)             |

예:

user:1 → { name: "John", age: 30 }
HSET user:1 name "John"
HSET user:1 age 30

2-5. List

| 항목          | 내용                                                  |
| ------------- | ----------------------------------------------------- |
| 개념          | 순서가 있는 문자열 리스트 (앞/뒤에 넣고 빼는 큐/스택) |
| 대표 명령     | LPUSH, RPUSH, LPOP, RPOP, LRANGE                      |
| 전통 자료구조 | Linked List, Queue, Stack                             |
| 활용 예       | 작업 큐, 최근 방문 기록, 메시지 목록 등               |

예:

["apple", "banana", "cherry"]
게이머 이벤트 로그, 최근 검색어 리스트처럼 순서가 중요한 데이터.

2-6. Set

| 항목          | 내용                                                    |
| ------------- | ------------------------------------------------------- |
| 개념          | 중복 없는(unordered, unique) 문자열 집합                |
| 대표 명령     | SADD, SMEMBERS, SISMEMBER, SINTER, SUNION               |
| 전통 자료구조 | HashSet                                                 |
| 활용 예       | 유니크 태그 모음, 오늘 로그인한 유저 집합, 권한 목록 등 |

예:

["apple", "banana", "cherry"] (중복 자동 제거)

logged_in_users:2025-11-23

#### Sorted Set (ZSet)

| 항목          | 내용                                                                                |
| ------------- | ----------------------------------------------------------------------------------- |
| 개념          | Set과 비슷하지만 각 원소에 **score(실수)**가 붙고, 그 score로 정렬                  |
| 대표 명령     | ZADD, ZRANGE, ZREVRANGE, ZRANK, ZREVRANK                                            |
| 전통 자료구조 | “(score, value)” 튜플을 정렬해두는 자료구조 (Redis 내부적으로 skiplist + hash)      |
| 활용 예       | 랭킹 시스템, 리더보드, 시간/점수 기반 정렬 목록, 지오 데이터(Geo가 내부적으로 사용) |

예:

[(100, "user1"), (95, "user2"), (80, "user3")] → 점수 높은 순 랭킹

#### Geospatial Indexes (Geo)

이것도 별도 타입이 아니라 내부적으로 Sorted Set을 사용한다.

| 항목          | 내용                                                               |
| ------------- | ------------------------------------------------------------------ |
| 개념          | 위도/경도 좌표를 저장하고, 반경 검색 등 공간 쿼리 지원             |
| 대표 명령     | GEOADD, GEOPOS, GEODIST, GEORADIUS (신버전에서는 GEOSEARCH)        |
| 전통 자료구조 | 공간 인덱스 (Redis는 내부적으로 좌표→score로 변환해서 ZSet에 저장) |
| 활용 예       | 주변 매장 찾기, 주변 유저 찾기, 지도 기반 서비스 등                |

예:

shop:locations 에 여러 매장의 좌표를 저장 후 “반경 1km 안의 매장” 조회

#### HyperLogLog

| 항목          | 내용                                                                                               |
| ------------- | -------------------------------------------------------------------------------------------------- |
| 개념          | **“서로 다른 개수” (카디널리티)**를 매우 작은 메모리로 추정하는 자료구조                           |
| 대표 명령     | PFADD, PFCOUNT, PFMERGE                                                                            |
| 전통 자료구조 | Probabilistic data structure (정확도 대신 메모리 절약)                                             |
| 활용 예       | UV(User 수), unique IP 수, unique 검색어 수 등 “정확히 몇 개냐”보다는 “대략 몇 개냐”가 중요한 통계 |

예:

PFADD uv:2025-11-23 user1 user2 user2 user3

PFCOUNT uv:2025-11-23 → “대략 3명”

#### Streams

| 항목          | 내용                                                                      |
| ------------- | ------------------------------------------------------------------------- |
| 개념          | 시간 순으로 append만 되는 로그/메시지 스트림. 각 메시지는 ID + 필드-값 쌍 |
| 대표 명령     | XADD, XRANGE, XREAD, XGROUP, XREADGROUP                                   |
| 전통 자료구조 | Append-only log, 메시지 큐, Kafka 비슷한 느낌의 스트림                    |
| 활용 예       | 이벤트 로그, 채팅 메시지, 작업 큐, 소비자 그룹 기반 분산 처리 등          |

예:

{"id": 1699999999-0, "message": "Hello", "userId": "123"} 같은 레코드들이 시간 순으로 쌓임

### 자료구조 관점 정리표

간단하게 “전통 자료구조” 기준으로 다시 한 번:

| Redis 타입        | 전통 자료구조 대응          | 핵심 활용 포인트               |
| ----------------- | --------------------------- | ------------------------------ |
| String            | 값(primitive / blob)        | 단일 값, 카운터, 캐시          |
| Hash              | HashMap / Object            | 객체(프로필, 설정)             |
| List              | Linked List / Queue / Stack | 순서 있는 로그/큐              |
| Set               | HashSet                     | 중복 없는 집합, 집합 연산      |
| Sorted Set (ZSet) | 정렬된 집합 (skiplist)      | 랭킹, 정렬 필요 목록           |
| Bitmap            | Bit array / Bitset          | 메모리 절약 boolean 집합       |
| Bitfield          | Packed struct               | 여러 상태/카운터를 비트로 압축 |
| HyperLogLog       | 확률적 구조                 | 대규모 유니크 수 추정          |
| Geo               | 공간 인덱스 (ZSet 기반)     | 반경 검색, 위치 기반 서비스    |
| Streams           | Append-only log             | 이벤트 스트림, 메시지 큐       |
