# 작성일

- 2025-10-23

# file은 무엇인가?

# 정의

파일은 1차원 선형 메모리 구조를 가진 데이터로 2차메모리를 사용하는 방법론이다.
파일은 기본적으로 메모리 공간안에 저장되어있는 정보이다.

## 2차 메모리 종류

2차 메모리는 하드디스크라 불리며 HDD와 SSD가 범용적으로 사용된다.

### HDD

- 물리적으로 플래터, 실린더, 트랙, 섹터 등 geometry가 있으며, 현대 OS/디스크는 LBA(Liner Block Addressing)이라는 선형 섹터번호를 제공한다.
- 파일의 논리 오프셋 -> LBA(논리 블록)으로 매핑된다.

### SSD

- SSD 같은 경우 트랙 자체가 존재하지 않기 때문에 페이지/블록 구조와 FTL(Flush Translation Layer) 내부에서 LBA <-> 물리 플래시 위치를 동적으로 매핑하고 웨어레벨링/가비지컬렉션을 수행한다.

파일을 입출력하는 것은 프로세스 이다.

## 파일의 논리적 구조

- 파일은 1차원 선형 구조이다.
  - 2차원 메모리(디스크: SSD 또는 HDD)에 존재하는 track의 주소들을 하나의 선형구조로 늘어뜨려놓은 것
- 파일의 크기
  - 파일의 크기는 데이터의 사이즈에 따라 자동으로 늘어난다.
  - 파일에 `Write`를 하는 것은 기본적으로 `append`이다. 때문에 OS에 따라 파일시스템이 허용하는 크기만큼 나무에 물주듯 자동으로 늘어난다.

## 연관 용어

- 스트림
  - 파일의 기본적인 논리 구조이다.
- 2차 메모리
  - 파일은 2차 메모리에 저장되는 정보다.
- 파일시스템
  - CRUD
    - Write
    - Read
- 탐색기
  - 탐색기의 기본 본질은 프로세스이며 파일에 접근(Access) 해서 CRUD 그리고 Execute릴 실행할 수 있다.
- 파일에 접근하기 위해 OS 단에서 권한이 반드시 필요하다.
- 버퍼
  - 메모리 공간을 관리하기 위한 객체

# 파일 읽기 쓰기

## 읽기

파일 시스템에서 읽기란 userMode에서 kernelMode 로 write 명령어를 요청하는 System Call이다. System Call을 요청하는 주체는 KernelMode이며 명령어를 전달하는 쪽은 UserMode에서 Thread에 의한 요청을 받는다. 요청을 받게된 시스템콜은 2차 메모리에 데이터를 영구적으로 저장하게 된다.

### Blocking I/O

쓰레드가 write 명령을 요청한 뒤 2차 메모리에 데이터 쓰기 작업이 완료될때 까지 기다리는 것을 Blocking I/O라고 하며 이때 쓰레드는 요청이 완료될 때까지 다른 작업을 하지 않고 오직 응답을 기다린다.

### Non-Blocking I/O

2차 메모리에 데이터를 쓰는 것은 OS에 의한 것이며 쓰레드는 write를 요청을 하고 기다리지 않고 다른 일을 처리하게되면 훨씬 좋은 성능을 발휘할 수 있게 된다. 때문에 이를 위해 write요청 후 바로 반환하여 다른 처리를 하도록 Non-Blocking I/O 메커니즘을 사용한다.

## 쓰기

# Tip

> JVM 자체가 userMode 프로세스이다.

# 참고자료

- [Java stream](https://www.elancer.co.kr/blog/detail/255)
