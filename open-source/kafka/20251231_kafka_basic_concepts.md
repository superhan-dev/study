# 1. 카프카 아키텍처

## 1.1 카프카 클러스터

카프카 클러스터는 메시지를 저장하기 위해 사용된다.
하나의 클러스터는 여러개의 브로커를 가지고있으며 메타데이터를 활용해서 카프카 브로커들이 메시지큐를 운영할 수 있도록 상태를 관리한다.

## 1.2 카프카 브로커

카프카 브로커는 클러스터 내부에서 카프카 메시지를 저장하는 인스턴스이다. 내부적으로는 토픽과 파티션으로 구조를 가지고 있으며 프로듀서로부터 받은 메시지를 저장하는 역할을 한다.

## 1.3. 주키퍼와 컨트롤러

주키퍼는 앞서 말했던 카프카 메타데이터를 가지고 있있으면서 선언된 카프카 상태를 유지하고 관리해주는 역할을 한다. 과거에는 주키퍼를 사용하여 메타데이터를 저장했지만 리소스 과사용을 이유로 최근 카프카는 Kraft를 사용하여 컨트롤러를 통해 메타데이터를 관리하면서 브로커들의 상태를 관리한다. 이로써 불필요한 리소스를 줄일 수 있게 되었다.

# 2. 카프카 기초

## 2.1 본질은 역시 파일이다.

메시지와 오프셋에 대한 값들은 모두 파일로 저장된다. 파일로 저장되기 때문에 비휘발성 데이터를 가지고있을 수 있게 되므로 카프카가 다시 다운 되었다가 살아나면 최신 상태를 유지하여 다시 이전까지 처리하던 작업을 계속해서 진행할 수 있게 된다.

## 2.2. 리플리케이션

카프카 브로커들은 리플리케이션을 통해 예비된 브로커들에게 리더 브로커 상태를 복제하도록 한다.
이를 리더와 팔로워 개념을 통해 좀더 알아볼 수 있다.

### 2.2.1. 리더 & 팔로워

리더는 현재 프로듀서로부터 메시지를 전달받는 주체이다. 하지만 리더 브로커가 만약 문제가 생겨 죽는 경우가 발생하면 그 처리를 다른 누군가가 해주어야 한다. 때문에 팔로워라는 예비 리더 브로커가 대기하면서 계속해서 리더의 상태를 polling한다. 리더와 팔로워는 In Sync Replicas라는 그룹안에서 자격 조건을 따져가며 철저하게 관리되다가 상황이 발생하면 리더를 재선출을 통해 팔로워 중 하나의 브로커가 리더가 된다.

## 2.3. 토픽

메시지는 토픽이라는 분류로 구분된다. 프로듀서와 컨슈머가 메시지를 공급하고 소비할때 어떻게 어디에 메시지를 저장할지 구분하는 이정표 같은 개념이라고 볼 수 있다.

토픽은 하나의 폴더로 관리되며 그 아래 파티션이라는 하위 토픽들을 가지고 있게 된다.

## 2.4. 파티션

파티션은 토픽의 하위 폴더 개념으로 메시지들을 병렬적으로 처리할 수 있도록 동작한다.
통상 하나의 컨슈머를 하나의 파티션에 매핑하여 효율적으로 메시지를 소비하며 트래픽을 처리할 수 있도록 설정한다.

만약 컨슈머가 부족한 상황이 발생한다면 나누어진 파티션만큼 현존하는 컨슈머들이 나누어서 작업을 처리하도록 한다.

## 2.5. 세그먼트

세그먼트는 토픽과 파티션 디렉터리 아래 존재하는 파일의 집합이다.
파티션 로그를 구성하는 물리적 파일 단위로 여러 메시지를 순차적으로 저장하는 append-only 로그파일이다.

Kafka의 세그먼트는 무한 스트림을 유한한 파일로 쪼개기 위한 단위이며,
이를 통해 삭제·인덱싱·캐시·복제를 단순하고 빠르게 유지할 수 있다.

### 2.5.1 세그먼트 구조

세그먼트는 다음에 보이는것과 같이 log, index, timeindex와 같은 Kafka record batch 바이너리 포맷이 들어있게된다.

```
topicA-0/              ← partition
  00000000000000000000.log       ← segment (log)
  00000000000000000000.index     ← offset index
  00000000000000000000.timeindex ← timestamp index

  00000000000000123456.log
  00000000000000123456.index
  00000000000000123456.timeindex
```

## 2.5.2 레코드 배치와 레코드

.log 파일에는 메시지들이 저장되며, Kafka는 RecordBatch를 append-only 방식으로 세그먼트 로그에 계속 이어붙인다.

Record는 Kafka에서 애플리케이션이 다루는 메시지의 최소 단위이고, Producer는 여러 Record를 모아 RecordBatch로 전송한다.
Broker는 이를 파티션 로그에 append하면서 레코드들에 오프셋을 순차적으로 할당한다(오프셋은 증가만 한다).

Consumer는 특정 오프셋부터 레코드를 읽고, 읽은 위치를 커밋 오프셋으로 저장하며(이 값도 증가), 로그의 데이터 자체를 삭제하거나 오프셋을 감소시키지는 않는다.

## 2.7. 메시지 단위

메시지 단위 정확히 정리

| 레벨         | 의미                                          |
| ------------ | --------------------------------------------- |
| Record       | 메시지 1개                                    |
| Record Batch | 여러 메시지를 묶은 단위 (압축/전송 최소 단위) |
| Segment      | 여러 batch를 담는 파일                        |
| Partition    | 여러 segment의 논리적 연결                    |
| Topic        | 여러 partition의 집합                         |
