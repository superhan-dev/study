# Set Vs Map

## 작성일

- 2025-10-21

# TreeSet

- Set은 기본적으로 중복을 허용하지 않고 순서에 상관없이 값을 저장하는 특징이 있다. 하지만 TreeSet은 내부 구조를 레드블랙 트리로 구성하고있기 때문에 값을 저장할 때 트리 순서대로 정렬을 하면서 저장하는 특징이 있다.

- Set은 검색시 Iterator를 사용하여 O(n)의 성능을 내지만 TreeSet을 사용하면 O(log n)의 성능을 낸다 때문에 저장속도보다 검색 속도가 중요할때 TreeSet을 사용할 수 있다.

# HashSet

- HashSet 은 Hash값으로 값을 해싱 → 버킷 인덱스 계산 - 원소의 hashCode()를 가져와 보정 해시(예: h ^ (h >>> 16))로 섞은 뒤
  index = (table.length - 1) & hash 로 버킷 위치를 정합니다.
- 충돌 처리
  - 같은 인덱스에 모이면 값이라도 같은 값이라는 것은 아니다. 따라서 값이 많이지면 Treeify를 해서 (레드블랙 트리 사용) 값을 트리 자료구조를 이용하여 저장한다. 따라서 성능은 O(log n) 이 된다.

# TreeMap

- Map은 기본적으로 Key:Value pair로 구현되어 키값에 따라 값이 매핑된다.
- Map은 put하는 값의 순서에 따라 저장이 되지만 TreeMap은 Key값을 오름차순으로 정렬한다. 때문에 Map을 구현할 때 순서가 중요한 상황에서 유용하게 사용할 수 있다.

# HashMap

Hash 값으로 키를 관리하는데 키의 `hashCode()`를 받아서 상위/하위 비트를 섞는 보정 해시를 만들고 `index = (table.length-1) & hash`로 버킷 위치를 정한다. 또한 배열 길이를 2의 제곱으로 유지한다.

## 해시 충돌

- 같은 인덱스로 떨어진 엔트리들은 연결리스트로 이어붙여 관라힌다.
- 한 버킷의 연결리스트 길이가 8이상으로 길어지면 레드블랙 트리로 바꿔 O(log n) 의 조회 성능을 유지한다.
- 길이가 6이하로 줄어들면 리스트로 돌리기도 한다.
- Thread safe하지 않다. 따라서 병렬 환경에서는 `ConcurrentHashMap`을 사용하는 것이 안정성을 보장할 수 있다.
