# “스칼라 치환(Scalar Replacement)”이란?

> 한 문장으로 요약하면 스칼라 치환이란 컴파일러 최적화이다.

- JIT (HotSpot C2/Graal)가 **탈출 분석(Escape Analysis)**로 어떤 객체가 메소드 지역에서만 쓰이고 밖으로 탈출(return)하지 않을 증명하면, 그 객체를 실제로 힙에 new 키워드를 사용하여 생성하지 않고 **객체의 필드들을 각각의 스칼라 값으로 분해해서 레지스터나 스택에만 보관하도록 코드를 재작성**합니다.
  - 그래서 new 자체를 할당 제거(allocation elimination)한다.

> 스칼라 변수란? => "원시값(또는 참조값) 하나로 표현되는 값"
> JIT은 이런 값을 레지스터에 두는 걸 선호하고(접근이 빠르기 때문에), 필요 시 스택을 씁니다.
> 즉, "스칼라 != 무조건 스택". -> 레지스터/스택 둘다 가능.

## 왜 스칼라 치환이 중요한가?

- Fewer Allocations
  - Object 할당의 수를 줄여주어 GC 시간 감소 + 캐시 지역성↑
    - 데이터가 “흩어진 힙”에 쪼개져 있지 않고 연속된 레지스터/스택 값 위주가 되어 **CPU 캐시 적중률(지역성)**이 좋아짐. (힙 여기저기 ‘포인터 따라가기(pointer chasing)’가 줄어든다는 뜻)
  - TLAB 할당/배리어 비용 ↓, GC의 마크/스윕/이동 대상이 줄어 GC 시간도 ↓.
- Less Code

  - 객체를 실제로 new하지 않고(할당 제거), 메서드 호출도 인라이닝되면 런타임에 실행되는 명령 수가 줄어들어.

    - 예: new StringBuilder → 내부 필드 초기화/널체크/경계검사/간접참조 등의 경로가 사라지고, “몇 개의 레지스터 연산”으로 치환됨.

  - 원래라면 obj.field를 읽을 때

  - obj 참조 로드 → 객체 헤더 건너뛰기 → field 오프셋 계산 → 메모리 로드
    이런 일련의 간접 참조 + 메모리 로드가 필요한데
  - 스칼라 치환이 되면 field 자체가 레지스터 변수로 존재. - → 메모리(힙) 접근 없이 바로 레지스터 읽기/쓰기로 끝남.

  - Remove need of pointer manipulation to access fields (필드 접근을 위한 포인터 조작 제거)

  - 위와 같은 이유. 객체 포인터를 역참조해서 오프셋 더하고 로드하는 과정(포인터 조작) 자체가 사라짐.
  - 결과적으로 분기/경계검사/널체크 일부도 사라지고, 루프에서 경계검사 제거(RCE), 언롤링, 벡터화 같은 2차 최적화가 더 잘 걸림.

## 어떻게 “객체를 쪼개나?” (개념적 그림)

코드 예시

```java
StringBuilder sb = new StringBuilder(32);
sb.append("A");
sb.append(x);
return sb.length();
```

JIT이 "sb는 탈출 안함"을 증명하면(어떻게 증명?) 내부 상태를 로컬 스칼라들로 펼칩니다.

### 탈출 안함을 증명하는 방법

#### “연결 그래프(Points-to / Connection Graph)” 분석

JIT(C2/Graal)은 컴파일 시 바이트 코드->IR을 만들고 그 IR 위에서 객체가 어디로 흘러가는지를 그래프 형태로 추적한다.

- 노드 종류(개념)
  - Alloc 노드: new 지점(예: new StringBuilder(...)).
  - Field/Array 노드: o.f, a[i] 등 필드/배열 슬롯.
  - Var/Phi 노드: 지역 변수, 분기 합류 지점(phi).
  - Call/Return 노드: 호출/반환 경계.
- 엣지(간선)
  - "이 변수/필드가 저 객체를 가리킬 수 있다."는 points-to 관계를 전파.

그래프를 만들고 나면, "이 new 객체가 어디까지 도달 가능한자를 계산해서 탈출 등급을 붙인다."

#### 탈출 등급(HotSpot의 3단계)

- NoEscape: 현재 컴파일 단위(메서드/인라인된 범위)를 벗어나지 않음.
  → 할당 제거, 스칼라 치환, 락 소거 가능.

- ArgEscape: 호출 인자로만 나감(호출 대상 안에서만 사용, 전역 공개 X).
  → 대개 락 소거/경량화, 필드 스칼라화 일부 가능(호출이 인라인되면 더 강하게 최적화).

- GlobalEscape: 반환, 전역/정적/외부 객체 필드/배열에 저장, JNI로 노출 등.
  → 힙에 실제로 있어야 함(할당 제거 불가).

#### “탈출”으로 간주되는 대표 패턴

아래 중 하나라도 보이면 보수적으로 GlobalEscape로 승격된다.

1. 반환

```java
return obj;   // 호출자에게 넘어가므로 탈출
```

1. 전역/정적/더 오래 사는 곳에 저장

```java
this.saved = obj; // this가 장수하면 obj도 장수
SomeClass.staticRef = obj;
array[k] = obj;
```

1. 다른 스레드로 게시(Publish) 가능성

- 공유 컬렉션에 넣기, 동기화 없이 다른 쓰레드가 볼 수 있는 곳에 저장 등.

1. 알 수 없는 메서드로 전달(캡처 가능성)

```java
unknown(obj);  // unknown이 obj를 저장/반환/스레드에 게시할 수 있음
```

1. JNI/네이티브 경계로 나감

- 네이티브가 뭘 할지 JIT이 모르면 보수적으로 탈출 처리.

1. 동일성 사용/락 사용

- `synchronized(obj)` 자체가 “탈출”은 아니지만, **객체의 정체성(identity)**가 의미를 가지므로 스칼라 치환이 제한된다.(락 소거가 증명되면 예외).

#### “탈출 안 함”으로 간주되는 패턴

반대로 아래가 모두 증명되면 NoEscape가 됩니다.

- 반환하지 않음: return 경로로 흘러가지 않음.
- 전역/장수 객체의 필드/배열에 저장하지 않음.
  - 저장하더라도 그 저장 대상도 지역/비탈출임이 연쇄적으로 증명.
- 메서드 호출 경로:
  - 호출이 인라인 되어 본문이 보이면, 그 안에서 역시 위 조건을 재귀적으로 확인.
  - 인라인이 안되더라도, HotSpot은 요약(Summary) 정보를 갖고 있어서 "이 메서드는 인자로 받은 객체를 저장/반환하지 않는다." 가 알려진 경우 ArgEscape/noEscape로 유지 가능(대표적으로 JDK 내부 인트린식/신뢰 메소드).
- 동일성 의존 없음: `identityHashCode`, 락, 참조 동일성의 의미 있는 사용 등이 없음.

> 즉, 인라이닝이 잘되면 범위가 커져서 NoEscape로 증명될 가능성이 높아진다. 인라이닝이 안되면 보수적으로 Arg/Global로 기울게 된다.

### 결정 이후 최적화

- NoEscape -> `new`제거(Allocation Elimination) + 스칼라 치환(필드들을 레지스터/스택으로 분해) + 락 소거/경량화 + 경계 검사 제거 등 루프 최적화가 확 열림.
- ArgEscape -> 대개 락 최적화는 가능하며, 완전 스칼라 치환은 제한적. 인라인이 되면 더 공격적으로 가능
- GlobalEscape -> 일반 힙 할당(그래도 TLAB에 빨리 할당, 다른 최적화는 별개로 적용)

#### NoEscape와 GlobalEscape 예시

```java
String f(int n) {
    StringBuilder sb = new StringBuilder(n*2); // Alloc 노드
    for(int i=0;i<n;i++) sb.append(i); // 필드 업데이트만, 외부 저장/반환 X

    // sb 결과를 쓰지 않음 -> sb는 NoEscape -> new 제거, 루프에서 스칼라화
    return "ok";
}

String g(int n) {
    StringBuilder sb = new StringBuilder(n*2);
    for(int i=0;i<n;i++) sb.append(i);

    // 최종 String은 반환되어 GlobalEscape, sb는 내부만 NoEscape
    return sb.toString();
}

void h(List<Object> sink) {
    Object o = new Object();
    sink.add(o); // sink가 전역적으로 보이면 o는 GlobalEscape
}
```

#### 실무 팁

- 인라인이 잘되게(작은, final 메서드롤 쪼개기 등)하면 EA 성공확률이 상승.
- 결과를 전역에 저장하지 말고, 호출자에게 바로 반환/소비 되도록 설계.
- JDK의 컬렉션/유틸 중엔 캡처하지 않는 경로가 많아, 인라인되면 ArgEscape로 떨어뜨릴 수 있음.
- JVM 플래그(정보 확인용):
  - -XX:+DoEscapeAnalysis(기본 on),
  - -XX:+EliminateAllocations, -XX:+EliminateLocks(기본 on),
  - 진단용: -XX:+PrintEliminateAllocations, -XX:+PrintEscapeAnalysis(버전에 따라).

---

## 한 줄 요약

JIT은 points-to 그래프로 객체 흐름을 추적해 반환/전역 저장/미지의 캡처/네이티브 노출이 없음을 증명하면 NoEscape로 분류합니다. 그러면 new를 없애고 스칼라 치환·락 소거 등 공격적 최적화를 적용할 수 있다.

# 참고 문헌

- [Microsoft - Improving HotSpot
  Scalar Replacement](https://jdconf.com/2024/downloads/JDConf%202024-Improving%20HotSpot%20Scalar%20Replacement-Soares.pdf)
