# 작성일

- 2025-11-10

# 생성자 대신 정적 팩터리 메소드를 고려하라

## 정적 펙토리 메소드를 사용시 장점 다섯가지

### 첫 번째

> 이름을 가질 수 있다.

생성자는 클래스 이름을 그대로 따라가므로 생성자로 인스턴스를 만들 때 정확한 생성 의도를 표현하기 어렵다. 하지만 정적 팩터리 메서드는 객체를 생성하기 위한 의도를 명확하게 표현할 수 있는 자유도를 준다.

```java
class Car {
    public enum EngineType { GASOLINE, DIESEL, HYBRID, ELECTRIC }
    private final String maker;
    private final String model;
    private final EngineType enginType;
    // 정적 펙토리 메서드로 생성자를 사용하기 위해 캡슐화 한다.
    private Car(String maker, String model, EngineType engineType){
        this.maker = maker;
        this.model = model;
        this.engineType = engineType;
    }

    // 정적 펙토리 메서드 생성시 new를 붙여 메소드 명 컨벤션을 지정하여 보다 규칙적으로 메소드명을 정할 수도 있다.
    public static Car newElectric(String maker, String model, EngineType engineType){
        return new Car(maker, model, engineType);
    }

    public static Car newGasoline(String maker, String model, EngineType engineType){
        return new Car(maker, model, engineType);
    }
}

public class Main {
    public static void main(String[] args) {
        // 전기차 생성
        Car electricCar = Car.newElectric("Tesla", "Model 3", Car.EngineType.ELECTRIC);
        // 가솔린차 생성
        Car gasolineCar = Car.newGasoline("Genesis", "G90", Car.EngineType.GASOLINE);
    }
}

```

### 두 번째

> 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

```java
class Car {
    public enum EngineType { GASOLINE, DIESEL, HYBRID, ELECTRIC }
    private final String maker;
    private final String model;
    private final EnginType enginType;

    // 정적 펙토리 메서드로 생성자를 사용하기 위해 캡슐화 한다.
    private Car(String maker, String model, EngineType engineType){
        this.maker = maker;
        this.model = model;
        this.engineType = engineType;
    }

    /* ---- 캐시(동일 스펙이면 기존 객체 재사용) ---- */
    private static final Map<String, Car> CACHE = new ConcurrentHashMap<>();
    private static String key(String maker, String model, EngineType engine) {
        return maker+ "|" + model + "|" + engine;
    }


       // 정적 펙토리 메서드 생성시 new를 붙여 메소드 명 컨벤션을 지정하여 보다 규칙적으로 메소드명을 정할 수도 있다.
    public static Car newElectric(String maker, String model, EngineType engineType){
        String k = key(maker, model, engineType);
        //
        return CACHE.computeIfAbsent(k, __ -> new Car(maker, model, engineType));
    }

    public static Car newGasoline(String maker, String model, EngineType engineType){
        String k = key(maker, model, engineType);
        return CACHE.computeIfAbsent(k, __ -> new Car(maker, model, engineType));
    }
}

public class Main {
    public static void main(String[] args) {
        // 전기차 생성
        Car electricCar = Car.newElectric("Tesla", "Model 3", Car.ELECTRIC);
        // 가솔린차 생성
        Car gasolineCar = Car.newGasoline("Genesis", "G90", Car.GASOLINE);
    }
}
```

#### flyweight pattern

Flyweight 패턴은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화 하는 구조패턴이다. 캐시 개념을 코드로 패턴화 한 것이다.
자주 변화하는 속성(extrinsit)과 변하지 않는 속성(intrinsit)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.

예를 들어 폭탄 피하기 게임을 만든다고 가정해보자. 폭탄이 화면에 보일때마다 인스턴스를 생성한다면 Heap 영역에 과도하게 메모리가 사용될 것이다. 이때 플라이웨이트 패턴을 사용해서 객체를 재생성 하지 않도록 하고 객체에서 폭탄이 가지고 있어야할 기본 속성은 계속해서 캐시에서 가져다 쓰되 화면에 새로운 폭탄처럼 보여져야 하기 때문에 좌표값을 변경해서 위에서 아래로 떨어지도록 설정할 수 있다.

상상해보면 위 케이스에서 얼마나 많은 메모리 절약이 가능할지 예측해 볼 수 있다.

이때 만약 쓰레드 경합이 발생하는 환경이라면 ConcurrentHashMap을 사용해서 동시성 제어까지 생각할 수 있다.

#### 참조 링크

- [Flyweight Pattern](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-Flyweight-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)

### 세 번째

> 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

### 네 번째

> 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

### 다섯 번째

> 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

## 단점

### 첫 번째

> 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

이는 상속보다 컴포지션을 사용하도록 유도하는 패턴이 될 수 있는데 이부분은 장점이 될 수 있다.

### 두 번재

> 정적 펙토리 메소드는 프로그래머가 찾기 어렵다.

명확히 들어나지 않아서 일일이 찾아봐야 가능하다.

#### 정적 펙토리 메소드 패턴을 자주 시용하는 메소드 명

다음은 정해져있는 컨벤션은 아니지만 관습적으로 흔히 사용되는 메소드 작명 패턴이다.

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드
  - 예: Date d = Date.from(instant);
- of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드
  - 예: Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
- valueOf: from과 of의 더 자세한 버전
  - 예: BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
- instance 혹은 getInstance: 매개변수를 받아 명시한 인스턴스를 반환한다. 하지만
