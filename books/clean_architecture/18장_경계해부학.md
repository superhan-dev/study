# 경계 횡단하기

경계를 횡단한다는 의미는 경계한쪽 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일이다.

적절한 위치에서 경계를 횡단하게 하는 비결은 소스코드 의존성 관리에 있다.
의존성이란 직관적으로 어떤 클래스를 import 하냐로 방향이 결정된다.
import 하는 쪽에 참조를 하는 쪽이고 당하는 쪽이 속하는 쪽이 된다.

의존성은 안쪽으로 향해야 한다.

- Domain/Application은 프레임워크(DB, HTTP, TypeORM, NestJS등)를 모르도록 바깥에서 안쪽으로 호출하되 안쪽이 바깥쪽을 호출해야할땐 인터페이스(Port)를 안쪽에 두고 바깥이 그것을 구현하게 해야한다. (Adapter)

예를 들어 useCase가 ORM의 Repository를 직접 import하게 해서 DB를 호출해 버리면 Application -> Interface 방향으로 의존성이 생긴다. 때문에 UserRepository 인터페이스(Port)를 정의하고 Infrastructure에서는 OrmUserRepository와 같은 (Adapter)를 구현해서 의존성 주입으로 연결하는 방법이 있다.

## 나쁜 예시

`infrastructure/typeorm-user.repository.ts`

```typescript
import { Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { UserEntity } from "./user.entity";

export class OrmUserRepository {
  constructor(
    @InjectRepository(UserEntity)
    private readonly repo: Repository<UserEntity>
  ) {}

  async findById(id: string) {
    return this.repo.findOne({ where: { id } });
  }
}
```

`application/get-user.usecase.ts`

```typescript
import { OrmUserRepository } from "../infrastructure/typeorm-user.repository";

export class GetUserUseCase {
  constructor(private readonly userRepo: OrmUserRepository) {}

  async execute(userId: string) {
    const user = await this.userRepo.findById(userId);
    if (!user) throw new Error("NOT_FOUND");
    return user;
  }
}
```

## 좋은 예시

- Application: Port(인터페이스) 정의
  `application/ports/user.repository.ts`

```typescript
export interface UserRepository {
  findById(id: string): Promise<{ id: string; name: string } | null>;
}
```

- Application: UseCase는 Port만 의존
  `application/usecases/get-user.usecase.ts`

```typescript
import { UserRepository } from "../ports/user.repository";

export class GetUserUseCase {
  constructor(private readonly userRepo: UserRepository) {}

  async execute(userId: string) {
    const user = await this.userRepo.findById(userId);
    if (!user) throw new Error("NOT_FOUND");

    // application은 "도메인/정책"만 신경씀
    return { id: user.id, name: user.name };
  }
}
```

- Infrastructure: Adapter(TypeORM 구현체)
  `infrastructure/typeorm/typeorm-user.repository.ts`

```typescript
import { Repository } from "typeorm";
import { InjectRepository } from "@nestjs/typeorm";
import { UserEntity } from "./user.entity";
import { UserRepository } from "../../application/ports/user.repository";

export class TypeOrmUserRepository implements UserRepository {
  constructor(
    @InjectRepository(UserEntity)
    private readonly repo: Repository<UserEntity>
  ) {}

  async findById(id: string) {
    const row = await this.repo.findOne({ where: { id } });
    if (!row) return null;
    return { id: row.id, name: row.name }; // application이 필요한 형태로 변환
  }
}
```

- NestJS DI로 연결 (의존성 “역전” 지점)
  `app.module.ts`

```typescript
import { Module } from "@nestjs/common";
import { GetUserUseCase } from "./application/usecases/get-user.usecase";
import { TypeOrmUserRepository } from "./infrastructure/typeorm/typeorm-user.repository";

@Module({
  providers: [
    GetUserUseCase,
    { provide: "UserRepository", useClass: TypeOrmUserRepository },
  ],
})
export class AppModule {}
```

위와 같은 형태로 경계 횡단하기를 관리할 수 있는 방화벽 Port/Adapter를 구축할 수 있다.
