# 작성일

- 2025-11-19

# 다형성 연습문제

## 문제

### 1. 개념 확인 OX (참/거짓)

1. (O/X) 의존성 역전 원칙(DIP)의 핵심은 “상위 모듈은 구체 클래스에 의존하고, 하위 모듈은 인터페이스에 의존해야 한다” 이다.
2. (O/X) IoC(제어의 역전)는 “프레임워크가 내 코드를 호출하는 구조”를 포함하는 개념이다.
3. (O/X) DI(의존성 주입)는 반드시 프레임워크가 있어야만 구현할 수 있다.
4. (O/X) Interface를 사용하는 이유 중 하나는 DIP를 지키기 위해 상위/하위 모듈이 모두 같은 추상에 의존하게 만들기 위해서이다.
5. (O/X) 스프링에서 new 키워드로 직접 객체를 생성하는 코드는 보통 DI 방식과는 거리가 멀어진다.

### 2. 개념 선택형

#### 6. DIP(의존성 역전 원칙)

다음 설명 중 DIP에 가장 가까운 것은?

- a. 객체 간 결합도를 낮추기 위해 항상 싱글톤 패턴을 사용하라는 원칙
- b. 상위 모듈과 하위 모듈이 모두 인터페이스 같은 추상에 의존하도록 하라는 원칙
- c. 모든 클래스는 오직 한 가지 책임만 가져야 한다는 원칙
- d. 의존성을 프레임워크가 대신 생성해 주입하도록 하라는 원칙

#### 7. IoC(제어의 역전)

다음 중 IoC가 드러나는 전형적인 상황은?

- a. main 메서드에서 직접 모든 객체를 생성하고 순서대로 호출할 때
- b. 라이브러리 함수를 내가 원하는 시점에 직접 호출할 때
- c. 웹 프레임워크가 HTTP 요청이 올 때마다 내가 등록해 둔 컨트롤러/핸들러 메서드를 호출할 때
- d. 유틸리티 클래스를 static 메서드로만 구성했을 때

#### 8. DI(의존성 주입)

다음 중 DI의 예로 볼 수 있는 것은? (복수 선택 가능)

- a. 생성자의 파라미터로 인터페이스 타입을 받고, 외부에서 구현체를 전달한다.
- b. 클래스 내부에서 new 로 필요한 구현체를 직접 만든다.
- c. 스프링에서 @Autowired 혹은 생성자 주입을 통해 의존 빈을 받는다.
- d. 정적 메서드 안에서 전역 싱글톤 객체를 직접 조회해서 사용한다.

### 3. 코드 기반 이해 문제

#### 문제 9

```java
public class FileLogger {
    public void log(String message) {
        System.out.println("FILE: " + message);
    }
}

public class OrderService {
    private final FileLogger logger = new FileLogger();

    public void order() {
        logger.log("Ordering...");
    }
}
```

- 9-1. 이 코드가 DIP 관점에서 문제가 되는 이유를 설명해라.
- 9-2. 이 코드를 DIP를 지키도록 리팩터링하기 위해 어떤 인터페이스 설계와 의존성 주입 방식을 적용할 수 있을지 간단히 서술하라(코드를 직접 써도 됨).

#### 문제 10 – IoC / DI 찾기

```java
@RestController
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping("/users/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }

}
```

- 10-1. 이 코드에서 DI(의존성 주입)가 적용된 부분을 찾고, “왜 이게 DI인가?”를 설명하라.
- 10-2. 이 컨트롤러가 호출되는 과정 전체(HTTP 요청 → 컨트롤러 메서드 실행)에서 IoC(제어의 역전)이 어떻게 드러나는지 흐름을 글로 설명해라.

#### 문제 11 – 콜백/리스너와 IoC

```java
public interface OnClickListener {
    void onClick();
}

public class Button {
    private OnClickListener listener;

    public void setOnClickListener(OnClickListener listener){
        this.listener = listener;
    }

    public void click() {
        if (listener != null) {
            listener.onClick();
        }
    }
}
```

- 11-1. setOnClickListener 메서드가 DI 관점에서 어떤 역할을 하는지 설명하라.
- 11-2. click() 메서드가 실행될 때, 제어의 역전(IoC)라는 관점에서 “누가 누구를 호출하는 구조로 흐름이 바뀌는지”를 설명하라.

### 4. 서술형 – 개념 정확도 체크

- 다음 문장을 보완/수정해서, 가급적 정확한 정의로 다시 써보라.
  - IoC는 프레임워크가 내 코드를 대신 호출하는 구조를 말하며, 우리는 프레임워크가 정해 놓은 규칙대로 코드만 등록해 두면 된다. (너가 생각하기에 부족한 부분을 보완해서 한두 문장 정도로 완성해보면 됨)
- 다음 문장을 틀린 부분이 있다면 고쳐서 다시 써보라.
  - DI는 프레임워크가 자동으로 객체를 생성해주는 기능이고, DIP는 프레임워크가 알아서 인터페이스를 구현해주는 원칙이다.
- 아래 문장을 DIP 관점에서 “상위 모듈 / 하위 모듈 / 추상 / 구체”라는 단어를 꼭 넣어서, 한 문단으로 다시 설명해보라.
  - 상위 모듈과 하위 모듈이 모두 인터페이스 같은 추상에 의존하도록 만들고, 구체 구현이 그 추상을 구현하게 하여 의존 방향을 뒤집는 것이 DIP이다. (더 쉽게, 더 잘 설명해도 좋고, 조금 더 어려운 용어를 써도 상관 없음)

### 5. 설계/적용 문제

아래와 같은 요구사항이 있을 때, DIP와 DI를 만족하는 구조를 설계해보라.

- 알림을 보내는 기능이 있다.
- 현재는 이메일로만 보내지만, 나중에 SMS, 푸시 알림 등으로 확장할 수 있어야 한다.
- NotificationService (상위 모듈)는 “어떤 방식으로 보내는지”는 모르고, 오직 “알림을 보낸다”는 추상에만 의존하고 싶다.
- 스프링을 사용한다고 가정한다.

요구 사항

- 15-1. 필요한 인터페이스와 구현체 클래스 이름을 정하고, 관계를 글로 설명하라.
- 15-2. 스프링에서 어떤 방식(예: 생성자 주입, @Component, @Qualifier 등)으로 DI를 구성할 수 있을지 서술해라.

---

## 풀이 & 피드백 노트

### 1~5번: OX + 기본 개념

- **1번 – ✅ 정답 + 표현만 살짝 수정**  
  1 아니다. 상위 모듈과 하위 모듈은 모두 추상에 의존해야하며…

  판단(O/X): 맞게 “X”라고 봤어요.

  보완:

  “의존성을 강하게 유지”는 표현이 애매해요. DIP는 **“결합도를 낮추면서, 의존을 추상 쪽으로 모으는 것”**이 핵심이라서:

  ❌ 의존성을 강하게 유지

  ✅ 구체 구현에 대한 직접 의존을 줄이고, 추상에만 의존하도록 해서 결합도를 낮춘다 가 더 적절해요.

- **2번 – ✅ 정답**  
  2 맞다. 프레임워크(하위) 에서 내가만든 모듈 (상위)의 추상적인 함수를 호출…

  IoC 핵심 표현 잘 잡았음:

  “내 코드가 프레임워크를 호출” → 라이브러리 스타일

  “프레임워크가 내 코드를 호출” → IoC/프레임워크 스타일

- **3번 – ✅ 정답 (설명 좋음)**  
  DI는 … 꼭 프레임워크가 아니라도 메뉴얼 DI를 할 수 있다.

  이걸 한 줄로 옮기면: → 3번은 X (거짓) 이고, 설명은 완전히 맞음.

  “프레임워크 없어도 DI는 가능하다” 정확히 짚었어요.

- **4번 – ✅ 정답**  
  맞다. 이것이 바로 DIP를 사용해서 세부사항이 추상에 의존하게 만든다.

  네가 쓴 설명 그대로 DIP 핵심입니다.

- **5번 – ❓ 의도는 맞지만, 질문에 직접 답은 안 했음**  
  원래 문장:

  (OX) 스프링에서 new로 직접 객체 생성하는 코드는 보통 DI 방식과는 거리가 멀어진다.

  너의 답:

  스프링은 빈을 선언하고 (…) DI를 주입할 수 있으므로 매우 밀접한 관계가 있다.

  의도 파악: 스프링과 DI가 밀접하다 → 이건 맞는 말인데,

  질문의 포인트는:

  “new로 직접 생성하는 건 DI랑 거리가 멀다 → O인가 X인가?”

  여기에 “O (참)”이라고 명시해줬으면 더 좋았음.

  정리:

  컨테이너가 관리하는 빈이 아닌 객체를 new로 직접 만들면,

  그 객체는 DI 컨테이너 밖에 있는 것 → DI의 이점(라이프사이클, 주입, AOP 등)을 못 씀

  따라서 문장은 O(참) 이고, 네 설명은 그 배경 설명으로 괜찮은 편.

### 6~8번: 선택형

- **6번 – ✅ 정답**  
  b 선택 + 나머지 옵션 설명 완전 좋음.

  “의존성을 프레임워크가 주입하라는 원칙은 IoC로 설계 개념이다”라고 했는데,

  엄밀히 말하면 “의존성을 프레임워크가 주입해 주는 구현 방식”은 DI에 더 가깝고,

  IoC는 그보다 더 넓은 개념(제어권 자체를 프레임워크가 쥔다)이에요.

  그래도 전체 이해 흐름은 괜찮음.

- **7번 – ✅ 정답 + 설명 좋음**  
  7 c번이며 … 디스패처 서블릿이 핸들러 어댑터를 통해 …

  정답: c

  스프링 MVC 동작 흐름까지 끌어와서 설명한 거 아주 좋음.

- **8번 – ✅ 정답 (a, c 선택한 걸로 이해)**  
  8 생성자의 파라미터로 인터페이스 타입… 두번째는 @Autowired…

  의도상 a, c가 정답이라고 잘 이해하고 있음.

  정리:

  a: 생성자 주입 → DI 맞음

  c: @Autowired(또는 생성자 주입) → DI 맞음

  b, d: 내부에서 new / 전역 싱글톤 조회 → DI X

### 9번: DIP + 리팩터링

- **9-1 – ✅ 문제 지적은 정확**  
  FileLogger가 new를 사용해서 … OrderService가 FileLogger에 의존하고있다.

  “OrderService가 구체 클래스 FileLogger에 직접 의존한다” → DIP 위반 지적 정확.

- **9-2 – △ DI는 맞는데, 아직 DIP는 완전히 지키진 못함**  
  네 리팩터링 코드:

  ```java
  public class OrderServie {
      private final FileLogger logger;

      public OrderService(FileLogger logger){ this.logger = logger;}

      public void order(){ this.logger.log("Ordering...") }
  }
  ```

  좋은 점:

  new FileLogger()를 내부에서 없애고 외부에서 주입 → DI 구현 맞음.

  하지만 DIP 관점에서는 아직 부족:

  여전히 OrderService가 구체 타입 FileLogger에 의존하고 있음.

  DIP를 제대로 지키려면:

  ```java
  public interface Logger {
      void log(String message);
  }

  public class FileLogger implements Logger {
      @Override
      public void log(String message) { ... }
  }

  public class OrderService {
      private final Logger logger; // ← 추상에 의존

      public OrderService(Logger logger) {
          this.logger = logger;
      }

      public void order() {
          logger.log("Ordering...");
      }
  }

  // 외부에서 주입
  OrderService service = new OrderService(new FileLogger());
  ```

  이렇게 하면: OrderService(상위 모듈)와 FileLogger(하위 모듈)가 둘 다 Logger (추상)를 사이에 두고 연결됨 → DIP 충족 / 주입 시점/방법은 DI.

### 10번: DI / IoC

- **10-1 – ✅ 대체로 잘 이해**  
  @RequiredArgsConstructor에 의해 … private final UserService userService; 를 호출함으로써 DI가 발생.

  맞습니다: private final UserService userService; + @RequiredArgsConstructor → 생성자 주입 기반 DI 정확히 짚었어요.

- **10-2 – △ IoC 설명 중 뒤 섞인 부분 조금 정리 필요**  
  네가 쓴 내용 중:

  이를 IoC라고 할수 있으며

  문제에서 보이는 IoC는 @RestController와 같이 개발자가 등록한 빈을 스프링이 생성해 줌으로써 싱글턴을 유지하게 되는데 이를 IoC라고 한다.

  맞는 부분: 스프링이 컨트롤러/서비스 빈을 생성·관리 → 개발자가 제어권을 직접 가지지 않음 → IoC의 한 형태 맞음.

  보완하면 좋은 부분: IoC의 핵심은 “HTTP 요청 → 디스패처 서블릿 → 핸들러 매핑 → 컨트롤러 메서드를 호출” 이 프레임워크가 주도한다는 점.

  우리는 단지 @RestController, @GetMapping 붙여 놓고 메서드만 만들어둔다 → 프레임워크가 알아서 호출.

  @GetMapping, @PathVariable을 “AOP 때문에 있는 기능”이라고 한 건 조금 부정확: 이건 스프링 MVC 요청 매핑 기능이고, AOP(횡단 관심사)는 주로 트랜잭션, 로깅, 보안 같은 데에서 프록시/어드바이스로 동작.

### 11번: Button / OnClickListener

- **11-1 – ✅ setter DI 설명 정확**  
  setter에 의해 DI가 된 케이스이다.

- **11-2 – ✅ IoC + DIP 관점 설명 좋음**  
  click()가 실행되면 … 상위 객체가 OnClickListener를 직접 정의하도록 함으로써…

  핵심 포인트 잘 잡았어요: 상위 코드가 OnClickListener 구현을 등록 → Button이 언제 그 로직을 호출할지 제어권을 가짐 → IoC / Button과 상위 코드는 둘 다 OnClickListener(추상)에 의존 → DIP 성립.

### 12~14번: 서술형 (개념 정리)

- **12 – ✅ 괜찮은 IoC 설명**  
  IoC은 프레임워크에서 미리 등록된 빈을 생성하고 실행 흐름에 따라 호출하는 것을 의미… 충분히 이해된 문장.

  살짝 더 날카롭게 쓰자면: IoC는 애플리케이션의 제어 흐름(객체 생성, 라이프사이클, 메서드 호출 시점)을 프레임워크가 주도하고, 개발자는 그 안에서 동작할 코드만 정의해 두는 구조를 말한다.

- **13 – ✅ 완전 잘 고쳤음**  
  DI는 객체를 주입해주는 것을 의미하며 … DIP는 상위 객체와 하위 객체가 모두 인터페이스를 통해 바라보도록 하는 원칙… 이 문장 자체가 거의 모범답안 수준.

- **14 – △ 의미는 맞는데, “의존 방향 역전”을 한 번 더 강조하면 좋음**  
  상위모듈과 하위 모듈이 모두 인터페이스와 같은 추상에 의존하도록 하여… 이미 핵심은 맞게 잡았어요.

  아주 조금 다듬으면:

  DIP는 상위 모듈과 하위 모듈이 모두 인터페이스와 같은 추상에 의존하도록 해서, 상위 모듈이 하위의 구체 구현에 직접 의존하지 않게 만드는 원칙이다. 이 과정에서 오히려 하위 모듈(구체 구현)이 추상에 의존하게 되어, 의존성의 방향이 “구체 → 추상” 쪽으로 뒤집힌다는 점이 핵심이다.

### 15번: 알림 설계 – DI/DIP 적용

네 코드:

```java
public interface MessgeSender {
    void send(String message);
}

@Component
@RequiedArgsConstructor
public class EmailSender implement MessageSender {
    private final Emailer emailer;

    @Override
    public void send(String message){
        emailer.sendEmail(message); // emailer를 통해 메세지를 보냄
    }
}

@Service
@RequiredArgsConstructor
public class NotificationService {
    private final EmailSender emailSender;

    public void service (String Message){ this.emailSender.send(message);}
}
```

- 👍 잘한 점  
  MessageSender 인터페이스 정의 → OK / EmailSender가 MessageSender 구현 → OK / Emailer 같은 하위 인프라 의존성 주입 → OK

- 🔧 아쉬운 핵심 한 군데  
  NotificationService가 인터페이스가 아니라 구현체 EmailSender에 의존하고 있음.

  ```java
  public class NotificationService {
      private final EmailSender emailSender; // ❌ DIP 위반
  }
  ```

  DIP를 만족시키려면:

  ```java
  @Service
  @RequiredArgsConstructor
  public class NotificationService {
      private final MessageSender messageSender; // ✅ 추상에 의존

      public void service(String message){
          this.messageSender.send(message);
      }
  }
  ```

  이렇게 바뀌어야 상위 모듈(NotificationService)이 “이메일인지, SMS인지, 푸시인지” 몰라도 되게 설계되는 거죠.

- @Qualifier 간단 설명  
  나중에 SMS, Push 구현이 생겼다고 치면:

  ```java
  @Component
  @Qualifier("emailSender")
  public class EmailSender implements MessageSender { ... }

  @Component
  @Qualifier("smsSender")
  public class SmsSender implements MessageSender { ... }
  ```

  그리고 의존성 주입할 때:

  ```java
  @Service
  @RequiredArgsConstructor
  public class NotificationService {

      @Qualifier("emailSender")
      private final MessageSender messageSender;

  }
  ```

  이렇게 하면 같은 인터페이스의 여러 구현체 중 어떤 걸 주입할지 선택할 수 있어요.

#### 총평

IoC / DI / DIP 개념은 거의 제대로 잡혀 있고, 헷갈리기 쉬운 부분(“DI vs IoC vs DIP 구분”, “DIP를 진짜 지킨 코드 형태”)도 이제 거의 이해한 상태.

지금 단계에서 가장 중요한 건:

“DIP를 지켰는지 체크할 때, 상위 모듈이 추상에만 의존하는지” 항상 습관적으로 보는 것.

DI 코드를 짤 때

“지금 이건 DI만 한 건지”

“아니면 DI + DIP까지 같이 지킨 건지” 구분해서 생각해보기.
