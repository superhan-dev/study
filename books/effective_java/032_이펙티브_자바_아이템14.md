# 작성일

- 2025-11-17

# Comparable을 구현할지 고려하라.

Comparable은 단연 비교를 하기 위해 구현하는 기능일 것이다.
자바 인터페이스로 `compareTo`라는 메소드를 overriding 해서 사용하며, equals와 비슷한 성격의 비교 메소드이다.

# 값을 비교하기 위해 알아야할 것

값을 비교하기 위해 반드시 값이 어떻게 저장되는지 알고있어야 하는데 이쯤에 나오는 단골 이론이 Call By Value, Call By Reference 이다.

## 값이 저장되는 원리

컴퓨터 과학에서 이론을 논할 때 주인공을 정확히 식별하는 것이 중요하다.
여기서 주인공은 함수로부터 호출되는 "값"이다. 어떤 값이 메모리에 저장될 때 주소값을 매핑하여 위치를 가지게 되고 그 위치안에 값이 저장된다.

함수를 호출해서 저장된 값을 가져올 때는 값이 존재하는 위치를 넘겨주거나(Call By Reference) 값을 직접 가지고 오기도 한다.(Call By Value)

## Call By Value

여기서 Call이란 함수가 호출될 때를 의미하며 함수에 값을 전달할 때 값을 복사해서 전달한다.
이렇게 복사를 하는 이유는 **원본 데이터를 보호**하기 위함이다.
하지만 그만큼 공간을 추가적으로 사용하기 때문에 너무 남발하여 사용하게 되면 성능상 이슈를 가지고올 수 있다.

## Call By Reference

위에서 말했던 **성능상 이슈를 해결하기 위해** 값이 존재하는 주소값을 넘겨주어 참조하게 만드는 방법이다.
이는 값을 복사함으로써 추가적인 공간을 만드는 Call By Value와는 다르게 주소값만 넘겨주게 되므로 저장공간을 절약하는 장점이 있다.

```java

class MyObject {
    int value = 5;
}

class Main {
    public static void main(String[] args) {
        // main메소드 안에서 int로 값을 생성하면 해당 변수는 스텍 프레임에 생성된다.
        int value = 5;
        // call by value이므로 값을 복사해서 넘겨주게 된다.
        changeValue(value);
        // 값이 왜 변경되지 않는가?
        // 파라미터로 int x 에서 받는 값과 int value로 선언된 값은 다른 주소값을 갖는다.
        System.out.println(value); // 5

        // MyObject 객체를 생성하게 되면 힙 영역에 obj인스턴스가 생성된다.
        MyObject obj = new MyObject();
        changeObject(obj);
        System.out.println(obj.value);
    }
    // 파라미터로 값을 받는 순간 하나의 int 타입 변수가 선언된다.
    // 함수로 값을 넘겨줄 때는 참조할 수 있는 주소값을 넘겨주어야 변경된 값을 할당할 수 있다.
    // 하지만 원시타입은 참조객체를 선언할 수 없는 특징을 가지고 있으므로
    // x에 값을 할당하면 새로 생성된 변수에 값을 할당하는 것과 같으므로 값이 변경되지 않는다.
    public static void changeValue(int x){
        x = 10;
    }

    // 파라미터로 참조 객체를 넘겨주면 객체의 주소값과 객체가 가지고 있는 속성들이 모두 넘어가게된다.
    // 때문에 obj에 값을 할당하면 클래스 생명주기에 영향을 주는 객체는 전역에서 값을 할당할 수 있게 된다.
    // 이는 캡슐화를 깨뜨리는 것으로 바람직한 방법은 아니며, 이러한 특징을 정확히 알고있어야 프로그램에서 버그를 피할 수 있다.
    public static void changeObject(MyObject obj){
        obj.x = 10;
    }
}

```

## 값 비교 방법

두 값을 비교하기 위해 가장 먼저 떠오르는 것은 `==` 연산자이다. 이때 `==` 연산자를 사용하면 주소값을 비교하게 된다. 때문에 참조형의 값을 정확히 비교하기 위해 equals가 사용된다.

### 원시 타입은 ==를 사용해도 되잖아요?

원시 타입은 기본적으로 주소값을 가지지 않는 형태로 사용된다. 그 이유는 원시 타입은 선언된 위치의 스택프레임이나 클래스의 지역변수로 저장이 되기 때문에 주소값을 별도로 갖지 않는다.

이러한 이유로 `==`연산자를 사용해서 그 값을 비교할 수 있는 것이다.

## equals는 어떻게 참조형의 값을 비교할 수 있나요?

참조형 인스턴스는 힙에 저장되며 객체가 저장되는 고유의 저장 공간을 가지며 그 공간의 주소값이 존재한다.

때문에 주소값을 비교하기 위해 equals를 사용한다면 재정의가 필요없지만 객체간의 비교가 필요할 경우 재정의 해서 사용해야 두 객체간에 값이 같은지 비교가 가능하다.

### 두 객체 비교 equals 사용 예시

```java
class Person {
    String name;
    int age;

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Person o){
        if(this == o) true;
        if(o == null || getClass() != o.getClass()) return false;

        Person other = (Person)o;
        return age == other.age &&
            Object.equals(name,other.name);
    }
}


public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("Han", 30);
        Person p2 = new Person("Han", 30);

        System.out.println(p1.equals(p2)); // equals를 재정의 했으므로 true.
    }
}

```

# Comparable

순서가 명확한 클래스를 사용한다면 Comparable은 유용하게 사용될 수 있다.

다음 set을 출력하면 a,b,c,d,e 순서대로 값이 출력된다.
이유는 String 이 Comparable를 구현하고 있기 때문이다.
Comparable은 수많은 제네릭 알고리즘과 컬렉션 사용시 궁합이 굉장히 좋다.

특별한 노력없이 정렬된 값을 받아볼 수 있기 때문이다.

```java
public static void main(String[] args) {
    Set<String> set = new TreeSet<>();
    Collections.addAll(set, "a", "c", "e", "b", "d");
    System.out.println(set);

}
```

## compareTo 메소드는 규약이 있다.

- 반사성
- 대칭성
- 추이성

## TreeSet과 HashSet의 차이

CompareTo 얘기하다말고 갑자기 TreeSet과 HashSet을 운운하는 이유는 equals로 비교하는 HashSet과 compareTo 메소드를 비교하는 TreeSet의 차이를 이야기 하고 넘어가야 하기 때문이다.

아래 두 set은 자칫 같은 결과가 있다고 생각할 수 있으나 equals 비교를 하는 HashSet은 문자열 비교를 하기 때문에 1.0과 1.00이 다른 값이 되지만 compareTo를 사용하여 값을 비교하는 TreeSet은

```java
TreeSet<BigDecimal> treeSet = new TreeSet<>();
HashSet<BigDecimal> hashSet = new HashSet<>();

BigDecimal b1 = new BigDecimal("1.0");
BigDecimal b2 = new BigDecimal("1.00");

treeSet.add(b1);
treeSet.add(b2);

hashSet.add(b1);
hashSet.add(b2);

System.out.println(treeSet); // [1.0]
System.out.println(hashSet); // [1.0, 1.00]
```

### HashSet 비교 방식

HashSet은 중복 판단을 equals + hashCode로 한다.

```java
HashSet<BigDecimal> hashSet = new HashSet<>();
hashSet.add(b1); // 1.0
hashSet.add(b2); // 1.00
```

BigDecimal에서는 다음과 같이 비교한다.

```java
new BigDecimal("1.0").equals(new BigDecimal("1.00")); // false
```

이유:

- BigDecimal.equals는
  - 값 + 스케일(scale)까지 모두 같아야 true
  - "1.0" → 값 1, 스케일 1
  - "1.00" → 값 1, 스케일 2
    → 스케일이 다르니 equals는 false

그래서 HashSet 입장에서는 서로 다른 객체 → 둘 다 넣어도 됨 → [1.0, 1.00]

### TreeSet이 값을 비교하는 방식

- TreeSet은 정렬기준(Comparator / compareTo)를 사용한다.
  - 순서도 정하고
  - 중복 여부도 정한다.

```java
TreeSet<BigDecimal> treeSet = new TreeSet<>();
treeSet.add(b1); // 1.0
treeSet.add(b2); // 1.00
```

#### BigDecimal compareTo 사용 시

BigDecimal은 Comparable<BigDecimal>을 구현하고 있고, compareTo는 숫자값만 보고 비교한다.

```java
// 예제 1) 값이 같다면 0
new BigDecimal("1.0").compareTo(new BigDecimal("1.00")); // 0
// 예제 2) 값이 다를때 -1
new BigDecimal("1.0").compareTo(new BigDecimal("2.0")); // -1
```

때문에 TreeSet은 내부적으로 `예제 1)`과 같이 두 값을 비교하므로 `1.0`과 `1.00`을 같다고 생각한다.
