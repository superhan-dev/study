# 작성일

- 2025-11-10

# 생성자 대신 정적 팩터리 메소드를 고려하라

## 정적 펙토리 메소드를 사용시 장점 다섯가지

### 첫 번째

> 이름을 가질 수 있다.

생성자는 클래스 이름을 그대로 따라가므로 생성자로 인스턴스를 만들 때 정확한 생성 의도를 표현하기 어렵다. 하지만 정적 팩터리 메서드는 객체를 생성하기 위한 의도를 명확하게 표현할 수 있는 자유도를 준다.

```java
class Car {
    public enum EngineType { GASOLINE, DIESEL, HYBRID, ELECTRIC }
    private final String maker;
    private final String model;
    private final EngineType enginType;
    // 정적 펙토리 메서드로 생성자를 사용하기 위해 캡슐화 한다.
    private Car(String maker, String model, EngineType engineType){
        this.maker = maker;
        this.model = model;
        this.engineType = engineType;
    }

    // 정적 펙토리 메서드 생성시 new를 붙여 메소드 명 컨벤션을 지정하여 보다 규칙적으로 메소드명을 정할 수도 있다.
    public static Car newElectric(String maker, String model, EngineType engineType){
        return new Car(maker, model, engineType);
    }

    public static Car newGasoline(String maker, String model, EngineType engineType){
        return new Car(maker, model, engineType);
    }
}

public class Main {
    public static void main(String[] args) {
        // 전기차 생성
        Car electricCar = Car.newElectric("Tesla", "Model 3", Car.EngineType.ELECTRIC);
        // 가솔린차 생성
        Car gasolineCar = Car.newGasoline("Genesis", "G90", Car.EngineType.GASOLINE);
    }
}

```

### 두 번째

> 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

이 특징은 어떤 의미를 지니고있을까? 메모이제이션을 통해 이미 생성됬던 객체를 사용할 수 있다.
규칙적으로 생성 메서드의 이름을 정의하면서 내부 캐시를 통해 같은 이름과 값을 갖는 인스턴스라면 불필요한 인스턴스를 생성하지 않을 수 있게 된다.

```java
class Car {
    public enum EngineType { GASOLINE, DIESEL, HYBRID, ELECTRIC }
    private final String maker;
    private final String model;
    private final EnginType enginType;

    // 정적 펙토리 메서드로 생성자를 사용하기 위해 캡슐화 한다.
    private Car(String maker, String model, EngineType engineType){
        this.maker = maker;
        this.model = model;
        this.engineType = engineType;
    }

    /* ---- 캐시(동일 스펙이면 기존 객체 재사용) ---- */
    private static final Map<String, Car> CACHE = new ConcurrentHashMap<>();
    private static String key(String maker, String model, EngineType engine) {
        return maker+ "|" + model + "|" + engine;
    }


       // 정적 펙토리 메서드 생성시 new를 붙여 메소드 명 컨벤션을 지정하여 보다 규칙적으로 메소드명을 정할 수도 있다.
    public static Car newElectric(String maker, String model, EngineType engineType){
        String k = key(maker, model, engineType);
        //
        return CACHE.computeIfAbsent(k, __ -> new Car(maker, model, engineType));
    }

    public static Car newGasoline(String maker, String model, EngineType engineType){
        String k = key(maker, model, engineType);
        return CACHE.computeIfAbsent(k, __ -> new Car(maker, model, engineType));
    }
}

public class Main {
    public static void main(String[] args) {
        // 전기차 생성
        Car electricCar = Car.newElectric("Tesla", "Model 3", Car.ELECTRIC);
        // 가솔린차 생성
        Car gasolineCar = Car.newGasoline("Genesis", "G90", Car.GASOLINE);
    }
}
```

#### flyweight pattern

Flyweight 패턴은 재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화 하는 구조패턴이다. 캐시 개념을 코드로 패턴화 한 것이다.
자주 변화하는 속성(extrinsit)과 변하지 않는 속성(intrinsit)을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.

예를 들어 폭탄 피하기 게임을 만든다고 가정해보자. 폭탄이 화면에 보일때마다 인스턴스를 생성한다면 Heap 영역에 과도하게 메모리가 사용될 것이다. 이때 플라이웨이트 패턴을 사용해서 객체를 재생성 하지 않도록 하고 객체에서 폭탄이 가지고 있어야할 기본 속성은 계속해서 캐시에서 가져다 쓰되 화면에 새로운 폭탄처럼 보여져야 하기 때문에 좌표값을 변경해서 위에서 아래로 떨어지도록 설정할 수 있다.

상상해보면 위 케이스에서 얼마나 많은 메모리 절약이 가능할지 예측해 볼 수 있다.

이때 만약 쓰레드 경합이 발생하는 환경이라면 ConcurrentHashMap을 사용해서 동시성 제어까지 생각할 수 있다.

#### 참조 링크

- [Flyweight Pattern](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-Flyweight-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)

### 세 번째

> 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

#### 인터페이스 기반 프레임워크

인터페이스를 정적펙터리 메서드의 반환타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이라는 의미는?

> 구현체는 숨기고, 인터페이스만 공개한다음, 객체 생성도 생성자가 아니라 정적펙터리 메서드를 통해 만들게 하는 프레임워크

라는 의미이다.

```java
public interface Cache {
    void put(String key, String value);
    String get(String key);
}

// 정적 팩터리 메서드 패턴을 활용했을때 얻을 수 있는 장점을 볼 수 있다.
// 클라이언트는 구현 클래스 이름을 전혀 몰라도 된다.
public interface CacheFactory {
    static Cache newLocalCache(){
        return new LocalCacheImpl();
    }
    // 구현체를 감추고 반환 타입은 `Cache` 인터페이스로 정의한다.
    static Cache newRedisCache(String host, int port){
        // 만약 RedisCacheImpl -> ClusteredRedisCacheImpl로 교체해도 클라이언트 코드 수정 없음
        return new RedisCacheImpl(host, port);
    }
}

// 클라이언트 코드
Cache cache = CacheFactory.newRedisCache("127.0.0.1", 6379);
```

이와같이 정의하면 `newRedisCache` 라는 이름으로 redis 캐시를 생성한다.
단, 내부에서 사용되는 구현은 언제든 바뀌어도 `Cache`클래스르 생성한다는 사실은 변하지 않으며, redis cache를 생성할 것이라는 계약은 메서드 명을 통해 여전히 유효하다.

이 패턴을 계속 확장하면

- 서비스 인터페이스
- 서비스 제공자 인터페이스
- 제공자 등록 API / 접근 API

등으로 구성된 서비스 제공자 프레임워크가 되는거고 effective java가 말하는 인터페이스 기반 프레임워크(JDBC, JPA)가 이와 같은 방식으로 구현되어있다.

java 8 이후부터 사용이 가능해졌다.
왜 이런 기능을 만들었는가?

> 결국은 변화에 유연하게 대응하기 위함이다.

- 장점에서 드러나듯, 외부에 내부 구현은 노출시키지 않을 수 있기 때문에 변화에 유현한 코드가 될 수 있다.

### 네 번째

> 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

### 다섯 번째

> 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

## 단점

### 첫 번째

> 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

이는 상속보다 컴포지션을 사용하도록 유도하는 패턴이 될 수 있는데 이부분은 장점이 될 수 있다.

### 두 번재

> 정적 펙토리 메소드는 프로그래머가 찾기 어렵다.

명확히 들어나지 않아서 일일이 찾아봐야 가능하다.

#### 정적 펙토리 메소드 패턴을 자주 시용하는 메소드 명

다음은 정해져있는 컨벤션은 아니지만 관습적으로 흔히 사용되는 메소드 작명 패턴이다.

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드
  - 예: Date d = Date.from(instant);
- of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드
  - 예: Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
- valueOf: from과 of의 더 자세한 버전
  - 예: BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
- instance 혹은 getInstance: 매개변수를 받아 명시한 인스턴스를 반환한다. 하지만
