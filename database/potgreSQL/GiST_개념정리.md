# 작성일

- 2025-11-27

# Generalized Search Tree

- 임의의 인덱싱 스키마를 구현하는 기본 template을 사용
- B-trees, R-tree 및 여러 인댁싱 스키마는 GiST를 통해 구현할 수 있다.

## B-Tree

밸런스드 트리로 균형이 잡힌 트리라고 할 수 있다. 트리 균형이 깨지면 들쑥날쑥한 성능이 나올 수 있고 트리의 O(log n) 성능이 깨져버기 때문에 자식 노드들은 계속해서 밸런스를 유지하는 트리 알고리즘이다.

**B-tree의 정의**

> 다수의 키와 다수의 자식을 가진 항상 균형잡힌 트리

### B-Tree 구조

```
    [10]
   /    \
 (<10) (>10)
```

B-Tree는 한 노드에 여러개의 키를 가질 수 있다.

```
노드: [ 10 | 20 | 35 ]

자식 4개:
  C0   C1   C2   C3

C0: <10 인 값들
C1: 10~20 사이 값들
C2: 20~35 사이 값들
C3: >35 인 값들
```

키들을 비교하여 크고 작은 값들이 적절한 위치에 찾아가 저장된다.
이때 다음 규칙을 따른다.

1. 한 노드의 키들은 졍렬된 상태
2. 자식 서브트리 값의 범위:
   - C0: < k1
   - C1: k1 <= 값 < k2
   - Cn: Kn <= 값 < Kn+1
   - Cm(마지막 자식 노드): km <= 값
3. 모든 리프노드는 같은 깊이를 갖는다.
   - 항상 균형잡힌 트리를 유지하기 때문에 성능은 언제나 O(log n) 성능을 유지한다.

## 실제 DB와 인덱스에서는 B+Tree를 사용한다.

B+Tree는 B-Tree와 같이 균형잡힌 트리이지만 조금 다른 특징을 가지고 있다.

1. 리프노트에만 실제 값 또는 포인터 레코드를 저장한다.
2. 나머지 노드들은 탐색용 키를 저장한다.
3. 리프노드 끼리는 연결 리스트로 구현되어있다.

## R-Tree

인접한 객체들을 그룹화하고 트리의 상위 레벨에서 최소 경계 사각형 으로 표현하는 것이다.
R은 Rectangle(사각형)을 의미한다.

모든 객체가 이 경계사각형 안에 있으므로 경계 사각형과 교차않은 쿼리는 포함된 객체들과도 교차할 수 없다.

> R-Tree도 균형탐색 트리이다.

# GiST 인덱스란?

특정 하나의 알고리즘이 아니라 연산자 클래스에 따라 다양한 알고리즘으로 값을 저장하는 인덱스 기법이다.
다르게 표현해서 알고리즘 자체가 아닌 틀이라고 할 수 있다.

GiST도 내부적으로는 균형잡힌 트리로 형성된다.

**연산자 클래스에따라 구성되는 인덱싱**

1. R-Tree
2. 공간 인덱싱
3. 범위 인덱싱

**연산자 클래스가 구현해야하는 콜백 함수들**

- consistent: 이 인덱스 엔트리가 쿼리 조건과 일관성이 있는지 판단
- union: 자식 노드들의 요약 값을 하나로 합치는 것
- compress / decompress: 인덱스에 저장할 압축/원복 로직
- penalty: 특정 노드에 새 엔트리를 넣었을 떄 얼마나 손해가 생기는지 평가
- picksplit : 노드가 꽉 찼을 때 어떻게 두 노드로 나눌지 결정하는 알고리즘
- same 등

## geometry를 사용한다면?

좌표기반 GiST 인덱스 알고리즘을 사용했을 때 다음과 같이 동작한다.

1. 새 geometry -> \*MBR계산
   - geometry 값을 넘겨주면 사각형 기준 가장 작은 축 졍렬 직사각형을 구하는 과정을 거쳐 DB에 저장되고 이를 기반으로 인덱스를 생성한다.

> \*MBR (Minimum Bounding Rectangle): 최소 경계 사각형
