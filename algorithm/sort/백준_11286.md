# 작성일

- 2025-11-12

# 절대값 힙

절대 값 힙 문제는 최소 절대값 힙을 구현해서 값을 넣고 빼는 것을 연습할 수 있는 문제다.

Priority Queue를 사용해서 Comparator를 커스텀할 수 역량을 확인할 수 있다. 때문에 이 문제를 풀기 전 Comparator와 PriorityQueue에 대해 공부하면 문제 풀이에 보다 도움이 된다.

# Comparator

`Comparator<T>`는 `interface`이다. 제네릭을 `T`로 명시했기 때문에 타입을 의미하며 입력되는 클래스를 지정해서 비교시 사용하겠다는 의미가 된다.

주석을 살펴보면 매개변수와 반환되는 타입, throw exception 종류 그리고 참고사항 등이 잘 설명이 되어있다.

## 어떻게 사용하는거지?

`int compare(T o1, T o2)`가 비교할 수 있는 함수이며 변수명 `o1`의 의미는 `the first object`라는 의미로 첫번째로 들어오는 매개변수 Object라는 의미로 사용된다. 또한 새로 들어온 값이라고 볼 수도 있다.

`o2` 는 `the second object`라는 의미로 뒤에 있는 값을 의미하여 기존에 있던 값을 의미하기도 한다.

## 두 값을 비교하는 원리는?

두 값(객체)을 비교해서 첫번째 값이 크다면 `양수`를 반환하고 두번째 값이 크다면 `음수`를 값이 같다면 `0`을 반환한다.

실무에서는 Comparator를 두 값을 비교해서 정렬할 때 유용하게 쓰인다. `return o1 - o2`과 같은식으로 배열을 오름 차순으로 정렬하거나 그 반대인 내림차순으로 정렬한다.

예를 들어 o1=1, o2=3 이라고 쳤을 때 두 값을 오름차순으로 넣고 싶다고 하자. 이때 연산 결과는 `1 - 3 = -2` 가 되므로 음수가 되기 때문에 o1이 o2보다 앞에 와야한다는 의미로 해석된다. 결과적으로는 0을 반환했을 때와 같지만 그 의미는 다르다.

### 음수 반환과 0 반환의 의미

이 두값을 반환했을 때 똑같은 결과가 나오는데 무슨 차이인거지? 라는 질문이 풀리지 않아 꽤나 답답했다. 핵심은 o1과 o2중 큰값을 뒤로 보낸다는 것이다.

두 값을 연산 했어도 큰값을 뒤로 보내기 뒤해 -1을 반환하는 것이다.

다음은 3가지 의미를 정리한 표이다.

## 요약 표

결과적으로 교확이 안된다는 의미는 갖지만 `같은 값`과 `작은 값` 이라는 의미다 다르게 쓰인다.

| 비교 결과  | 의미              | 스왑 여부 | 값의 관계   |
| ---------- | ----------------- | --------- | ----------- |
| 음수 (< 0) | 앞의 값이 더 작음 | ❌ (유지) | 순서상 앞   |
| 0          | 두 값이 같음      | ❌ (유지) | 동등(equal) |
| 양수 (> 0) | 앞의 값이 더 큼   | ✅ (스왑) | 순서상 뒤   |

## 문제 풀이

위 모든 항목들을 알았다면 문제를 풀 수 있다.
먼저 Comparator를 정의한다.

### Comparator 정의

절대값을 비교해서 절대값이 같을 때 음수를 먼저 반환하도록 한다.

```java
class MyComparator implement Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2){
        int a1 = Math.abs(o1);
        int a2 = Math.abs(o2);
        // 두 절댓값이 같다면,
        // 앞의 값이 더 클 경우(o1이 양수이고 o2가 음수인 경우),
        // 1을 반환하여 o1을 뒤로 보냄으로써 음수를 양수보다 앞에 오게 한다.
        if(a1 == a2) return o1 > o2 ? 1 : -1;

        return a1 - a2;
    }
}
```

### 풀이 코드

```java

class Main {
    public static void main(String[] args) {
        try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))){
            int n = Integer.parseInt(br.readLine());

            int[] arr = new int[n];
            for(int i=0;i<n;i++) arr[i] = Integer.parseInt(br.readLine());

            PriorityQueue<Integer> pq = new PriorityQueue<>(new MyComparator());

            for(int i=0;i<n;i++){
                if(arr[i] == 0){
                    if(pq.peek() != null){
                        System.out.println(pq.poll());
                    } else {
                        System.out.println(0);
                    }
                } else {
                    pq.add(arr[i]);
                }
            }
        } catch (Exception e) {}
    }
}

```

# 보다 나은 코드는?

## Comparator 에서 발생할 수 있는 잠재적 위험

`return a1 - a2`를 해서 큰 값을 뒤로 보내는 처리를 했는데 만약 int의 범위를 벗어나 오버플로우가 날 수 있다.

int의 범위는 `-2,147,483,648 ~ 2,147,483,647` 인데 `2,147,483,648` 은 int로 표현할 수 없기 때문이다. 때문에 만약 정말 큰 수를 비교할 경우라면 보다 안전한 코드를 만들어야할 수도 있다. 하지만 상식 선에서 흔히 다뤄지는 수는 아니므로 일반적인 알고리즘에서는 발생하지 않는다.

### 더 안전하게 하려면?

`return o1 > o2 ? 1 : -1` 이와 같은 명확한 계약 조건을 제시하거나 `Integer.compare`를 사용해서 비교하면 된다.

```java
return Integer.compare(a1, a2);
```

# 알고리즘 풀이를 해야하는 이유

AI 시대에도 알고리즘을 풀어야 하는 이유는 문제를 해석하고 어떤 자료구조를 사용해서 접근할지 학습을 해야하기 때문이다. AI를 통해서 문제를 풀어도 적당한 성능으로 풀어주는 것이다. 하지만 만약 AI가 PriorityQueue를 사용했거나 그렇지 않았을 때, 또은 Comparator나 Comparable 을 사용해서 문제를 풀었을 때 왜 그런 자료구조와 클래스를 사용했는지 각 클래스의 용도가 무엇인지 모른다면 개발자는 코드에 대한 제어권을 잃어 버리게 된다.

AI를 사용해서 업무나 학습을 한다는 것은 매우 편리해졌다. 일반적으로 학습했다면 Overflow나 TimSort라는게 있다는 것까지 접근하는 것은 쉽지 않았을 것이다. 보다 빠른 시간에 더 깊은 이론에 접근할 수 있다는 것은 명백하다.

하지만 코드를 짤 수 없는 사람이 AI를 돌린다면 프로그래밍의 제어도 떨어질 뿐더러 본질을 잃어버리게 될 수 있다.

때문에 깊게 사고하고 날카롭게 질문을 하는 역량이 그 어느때보다 중요한 시기인듯 하다.
