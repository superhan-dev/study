# 작성일

# 단지 번호 붙이기

# 문제 해석

1이 아닌 문자들도 순회를 해야하는 상황이며 4방향이 이어지는 상황에서 이어진 1들을 탐색해야하는 알고리즘이기 때문에 dfs를 사용하면 보다 효율적으로 처리할 수 있을 것으로 생각했다.

## 시간복잡도

크기는 `5<N<25`이기 때문에 1초동안 1억번까지 연산 가능하기 때문에 시간복잡도가 `O(n^2)` 까지 나오는 DFS로 해결이 가능할 것.

# 코드

```javascript
const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\n");
  const n = Number(input[0]);
  const arr = Array.from({ length: n }, () => []);

  for (let i = 0; i < n; i++) {
    const row = input[i + 1].split("").map(Number);
    arr[i] = row;
  }

  solution(n, arr);
}

function solution(n, arr) {
  const m = arr[0].length;
  const visited = Array.from({ length: n }, () =>
    Array.from({ length: m }, () => false)
  );

  let homeCount = 0;
  const answers = [];
  const dy = [-1, 1, 0, 0];
  const dx = [0, 0, -1, 1];

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (arr[i][j] === 1 && !visited[i][j]) {
        dfs(i, j);
        answers.push(homeCount);
        homeCount = 0;
      }
    }
  }

  function dfs(y, x) {
    if (visited[y][x]) return;
    homeCount++;
    visited[y][x] = true;

    for (let i = 0; i < 4; i++) {
      let ny = y + dy[i];
      let nx = x + dx[i];

      if (ny >= 0 && nx >= 0 && ny < n && nx < m && arr[ny][nx] === 1) {
        dfs(ny, nx);
      }
    }
  }

  answers.sort((a, b) => a - b);
  console.log(answers.length);
  answers.forEach((a) => console.log(a));
}

main();
```
