# 작성일

- 2025-12-14

# 백준 2178

# 문제 해석

움직일 수 있는 칸이 주어졌을때 n,m의 위치로 이동할때 지나야하는 최소 칸수를 구한다.

BFS 순회를 돌면서 구현하는 문제이며, queue를 생성해서 첫번째 배열을 넣는다.
매트릭스는 2차원 배열로 방향을 움직일 수 있는 방향 배열이 필요하다.

# 요구 스킬

1. 문자열 파싱을 통한 매트릭스 생성
   - 어떻게 만들어야할까
     - 이차원 배열을 만들어서 매트릭스를 생성한다.
     - 4방향을 도는 dy, dx 배열을 만든다.
     - range 를 넘어서지 않는 다면 계산을 한다.
       - range계산하는 방법을 모름
2. BFS 탐색
   - visited 배열을 만들어서 탐색한 곳이 아니라면 다시 탐색하도록 한다.
   - queue를 사용하여 BFS 탐색을 진행하는 방법

# 코드

```javascript
const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\n");

  const [n, m] = input[0].split(" ").map(Number);
  const metrics = Array.from({ length: n }, () => []);

  for (let i = 0; i < n; i++) {
    const row = input[i + 1].split("");
    metrics[i] = row;
  }

  const dy = [-1, 1, 0, 0];
  const dx = [0, 0, -1, 1];

  const dist = Array.from({ length: n }, () =>
    Array.from({ length: m }, () => -1)
  );
  const queue = [[0, 0]];
  dist[0][0] = 1;

  let head = 0;
  while (head < queue.length) {
    const [y, x] = queue[head++];

    for (let i = 0; i < 4; i++) {
      let ny = y + dy[i];
      let nx = x + dx[i];

      let isBounded =
        ny >= 0 &&
        ny < n &&
        nx >= 0 &&
        nx < m &&
        metrics[ny][nx] === "1" &&
        dist[ny][nx] === -1;

      if (isBounded) {
        dist[ny][nx] = dist[y][x] + 1;
        queue.push([ny, nx]);
      }
    }
  }
  console.log(dist[n - 1][m - 1]);
}

main();
```

# 새로 배운 것

1. head index를 사용해서 queue의 index를 탐색하면 shift보다 좋은 성능을 낼 수 있다.
   그 이유는 shift를 하면 첫번째 value를 pop한 후에 다시 나머지 값을 당겨오는 작업을 내부적으로 하기 때문에 성능상 불리해진다.
   index를 사용하면 포인터로 값을 바라볼 수 있게 되므로 내부적으로 값의 이동없이 shift를 할때와 똑같이 동작하면서 성능은 챙길 수 있게 된다.

```javascript
let head = 0;

while (head < queue.length) {
  const [y, x] = queue[head++];
}
```
