# 백준 1874 풀이

# 논리 및 출제 의도

## 논리

값을 입력받아 현재 스택에 쌓여있는 값들과 비교해서 입력받은 값보다 현재 스택에 있는 값이 적다면 값을 push하고 크다면 pop을 연산하면서 알고리즘을 실행하여 + 또는 -를 출력하는 방식이다.

이때 값을 출력할 수 없다면 No를 반환해야하는데 만약 현재 Top에 있는 값과 다음에 출력하고자 하는(input 값)을 비교 했을 때 input값이 더 크다면 Top 아래는 Top보다 작은 값들밖에 없게되므로 출력할 수 없는 상태가 된다.

```
pop 5 -> 스택: [4,3,2,1] (top = 4)
위와 같은 상황이 있다고 했을 때 다음으로 출력하고싶은 값이 3이라면
4(top) -> 3(input)을 출력해야 되는데 3을 출력하려면 4를 먼저 pop해야한다.
하지만 수열은 3이므로 -> 모순 -> 불가능
```

## 출제 의도

1. 스텍은 LIFO의 출력 순서를 갖는 자료구조이다. 문제에서 스텍에 대한 이해를 묻는 의도는 이러한 원리를 아느냐 이고 문제의 흐름을 스택에 담아 출력했을 때 결과값을 얻어낼 수 있는지를 통해 스택을 이해했는지 확인한다.

1. 자료구조 사용
   - ArrayDeque를 사용하면 Stack 클래스를 사용하는 것 보다 더 나은 성능을 낼 수 있다. 하지만 ArrayDeque를 사용시 주의할 사항들과 숙지하고 있어야할 사항들이 있다.
   - StringBuilder를 사용

# 성능

## ArrayDeque

- Deque는 interface 하여 구현된 객체로 Resizable-array이다.
  - push를 하면 grow 알고리즘을 통해 capacity를 늘린다.
- Thread safe하지 않다.
- Stack 으로 사용할 수 있고 Queue로도 사용할 수 있다.
  - Stack으로 사용시 더 빠른 성능을 낸다.
  - Queue로 사용시 LinkedList로 Queue를 구현하는 것 보다 더 빠르다.
- 모든 동작에서 상수시간을 반환한다.

## Why StringBuilder?

보통 자바에서 문자열을 다루기 위해 String을 사용하는데 String을 사용해서 문자열을 다루지 않는 이유가 있다.
String은 기본적으로 불변 객체이다. 때문에 빈번히 변경이 발생하는 연산을 하게되면 String pool에 계속해서 객체가 생성된다. 이는 메모리 사용량을 증가시켜 성능에 악영향을 미치게 한다.

StringBuilder 사용해야하는 이유에 대한 정확한 논리를 가지고 있어야 한다.

# 코드

```java
import java.util.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        int[] arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = Integer.parseInt(br.readLine());
        }

        ArrayDeque<Integer> stack = new ArrayDeque<>();

        StringBuilder sb = new StringBuilder();
        int num = 1;

        boolean isPossible = true;

        for(int i=0;i<n;i++){
            int curr = arr[i];
            if(curr > num) {
                while(curr >= num){
                    stack.push(num++);
                    sb.append("+\n");
                }
                stack.pop();
                sb.append("-\n");
            } else {
                int popped = stack.pop();
                if(popped > num) {
                    isPossible = false;
                    System.out.println("No");
                    break;
                }
                sb.append("-\n");
            }
        }

        if(isPossible){
            System.out.println(sb);
        }
        br.close();
    }
}

```
