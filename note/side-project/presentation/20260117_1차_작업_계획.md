# Phase 1 기반 인프라 및 데이터 셋업

1. 리눅스 PC(맥미니) 환경 구축:

- Docker를 활용해 PostgreSQL + PostGIS 컨테이너 실행.
- OSM Brazil 데이터 임포트: osm2pgsql 도구를 사용하여 브라질 도로망 데이터를 DB에 적재.
- Olist 데이터셋 적재: CSV 데이터를 PostgreSQL 테이블로 이관.
- 내부망 포트포워딩을 통한 외부 접근 가능하도록 설정.
  - 외부 프로그램에서 접근할 수 있도록 셋팅

2. 초기 재고(Inventory) 생성:

- olist_products_dataset을 기준으로 각 seller_id별 초기 재고 데이터를 생성.
- 전략: 과거 주문 내역을 분석하여 판매량이 높은 상품 위주로 재고를 할당하거나, 모든 셀러에게 임의의 재고(예: 50~100개)를 부여하여 '품절' 이벤트가 발생할 수 있는 환경 구축.

# Phase 2 데이터 리플레이 및 Kafka 파이프라인

1. Airflow Replay DAG 작성:

- order_purchase_timestamp를 기준으로 데이터를 정렬 후 읽기.

- 시간 가속 로직: 실제 1시간을 1초로 계산하는 등의 배속 설정을 넣어 Kafka의 order.created 토픽으로 전송.

2. 입고(Inbound) 이벤트 시뮬레이터:

- 재고가 소진된 상품에 대해 일정 시간 후 재고가 보충되는 이벤트를 생성하여 inventory.replenished 토픽으로 발행한다. 이는 '재고가 있을 때 배송 시간이 얼마나 단축되는지' 비교하는 트리거.

# Phase 3 실시간 로직 구현 (Spring Boot) (3~4주차)

Kafka로 들어오는 이벤트를 받아 실시간으로 계산을 수행한다.

1. 실시간 셀러 랭킹 엔진:

- 주문 이벤트가 발생할 때마다 해당 셀러의 배송 지연율, 재고 상태를 계산하여 Redis에 실시간 랭킹을 업데이트.

2. 배송 지연 예측(Risk Engine):

- 설계하신 zip_road_profile을 활용하여, 주문 시점에 특정 경로의 도로 품질이 낮거나 거리가 멀 경우 '지연 주의' 알림 이벤트를 발행.

3. 효용성 검증 로직:

- Scenario A (현실): 실제 과거 데이터상의 배송 시간.
- Scenario B (최적화): 제안하는 경로 및 재고 배정 시 예상 배송 시간.

이 두 값을 비교하여 '배송 시간 단축분'을 실시간으로 계산.

# Phase 4: 타임트래블 UI 및 시각화

사용자가 '빨리감기'의 결과를 체감할 수 있는 화면을 구성한다.

1. 실시간 대시보드 (Grafana 또는 Custom UI):

- 현재 리플레이 중인 '가상 시간'을 표시한다.

2. 셀러 랭킹 보드: 실시간으로 순위가 변동되는 리더보드.

- 지연 알림 리스트: 실시간으로 발생하는 risk.predicted 이벤트 스트림.

3. 지도 시각화 (Deck.gl 추천):

- 브라질 지도 위에 주문 발생 지점과 배송 경로를 선으로 표시한다.
- 재고가 부족하여 멀리 있는 셀러에게 배정될 때와, 가까운 셀러에게 재고가 있어 바로 배송될 때의 경로 차이를 시각적으로 보여준다.

# 테이블 설계

- 대리 키 사용: 모든 테이블에 BIGSERIAL 타입의 id를 PK로 설정하여 데이터 연산 속도를 최적화.

- 가상 시간(replay_timestamp) 추가: Airflow로 과거 데이터를 땡겨올 때, 리플레이되는 "시뮬레이션상의 현재 시간"을 기록하여 프론트엔드에서 타임트래블 UI를 구현하기 쉽게 한다.

- 검증 지표 중심: simulation_efficiency_logs를 통해 프로젝트의 핵심 결과물인 '재고 관리로 인한 배송 시간 단축'을 수치로 바로 뽑을 수 있게 설계.

## 1. 셀러 랭킹 테이블 (Seller Ranking)

과거 데이터를 집계하여 셀러의 퍼포먼스를 점수화합니다. olist_order_items, orders, reviews 테이블을 Join하여 생성한다.

```sql

CREATE TABLE seller_rankings (
id BIGSERIAL PRIMARY KEY,           -- 내부 관리용 PK
    seller_id VARCHAR(32) NOT NULL,     -- olist_sellers_dataset 매핑용 (FK 역할)
    speed_score DECIMAL(5, 2),          -- 출고 속도 점수 (0~100)
    reliability_score DECIMAL(5, 2),    -- 정시 배송 점수 (0~100)
    satisfaction_score DECIMAL(5, 2),   -- 고객 만족도 점수 (0~100)
    consistency_score DECIMAL(5, 2),    -- 운영 일관성 (표준편차 기반)
    total_score DECIMAL(5, 2),          -- 가중치 합산 총점
    seller_tier VARCHAR(20),            -- PLATINUM, GOLD, SILVER, BRONZE
    base_timezone VARCHAR(50),          -- 셀러 소재지 타임존
    updated_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT uq_seller_id UNIQUE (seller_id) -- seller_id로 중복 가입 방지
);

-- 빠른 조회를 위한 인덱스
-- 랭킹 조회를 위한 인덱스 (점수 높은 순 정렬 최적화)
CREATE INDEX idx_seller_rankings_total_score ON seller_rankings (total_score DESC);
```

2. 배송 지연 알림 및 리스크 관리 테이블 (Delivery Risk)
   OSM 데이터(도로 품질)와 주문 정보를 결합하여 지연 리스크를 실시간으로 기록한다.

```sql

CREATE TABLE delivery_risk_notifications (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(32) NOT NULL,      -- olist_orders_dataset 매핑
    risk_level VARCHAR(10),             -- CRITICAL, WARNING, NORMAL
    risk_type VARCHAR(30),              -- ROAD_CONDITION, BACK_ORDER, WEATHER, DISTANCE
    risk_cause_detail TEXT,             -- 구체적인 지연 원인 (예: "비포장 도로 비율 60% 상회")
    expected_delay_hours INTEGER,       -- 예상 지연 시간
    replay_timestamp TIMESTAMP,         -- 시뮬레이션 상의 가상 발생 시간 (UI 연동 핵심)
    is_resolved BOOLEAN DEFAULT FALSE,  -- 조치 완료 여부
    created_at TIMESTAMP DEFAULT NOW()
);

-- 타임트래블 UI에서 시간순으로 알림을 뿌려주기 위한 인덱스
CREATE INDEX idx_risk_replay_time ON delivery_risk_notifications (replay_timestamp);
```

3.  입고 이벤트 및 재고 알림 테이블 (Inventory Events)
    재고가 안전 재고 미만으로 떨어지거나 다시 채워질 때의 이벤트를 기록한다.

```sql
CREATE TABLE inventory_stock_alerts (
    id BIGSERIAL PRIMARY KEY,
    product_id VARCHAR(32) NOT NULL,    -- olist_products_dataset 매핑
    seller_id VARCHAR(32) NOT NULL,     -- olist_sellers_dataset 매핑
    alert_type VARCHAR(30),             -- STOCK_LOW, OUT_OF_STOCK, REPLENISHED
    current_stock INTEGER,              -- 이벤트 발생 당시 재고량
    threshold_value INTEGER,            -- 당시 설정된 안전 재고 기준치
    replay_timestamp TIMESTAMP,         -- 가상 시간 (UI 연동)
    created_at TIMESTAMP DEFAULT NOW()
);

-- 특정 셀러의 재고 흐름 추적을 위한 인덱스
CREATE INDEX idx_inv_alert_history ON inventory_stock_alerts (seller_id, product_id, replay_timestamp);
```

4. 효용성 검증 테이블 (Efficiency Tracking)

"재고 관리 시스템이 있었다면 얼마나 빨라졌을까?"를 검증하는 가장 중요한 테이블입니다.

```sql

CREATE TABLE simulation_efficiency_logs (
    id BIGSERIAL PRIMARY KEY,
    order_id VARCHAR(32) NOT NULL,
    actual_seller_id VARCHAR(32),       -- 과거 데이터 상의 실제 배송 셀러
    optimized_seller_id VARCHAR(32),    -- 시스템이 재고를 고려해 추천한 최적 셀러

    -- 시나리오 비교 데이터
    actual_delivery_hours FLOAT,        -- 실제 배송 소요 시간 (As-Is)
    estimated_optimized_hours FLOAT,    -- 시스템 추천 시 예상 소요 시간 (To-Be)
    saved_hours FLOAT,                  -- 단축된 시간 (Actual - Optimized)

    routing_logic_version VARCHAR(10),  -- 적용된 알고리즘 버전 (예: 'v1.0')
    is_stock_available BOOLEAN,         -- 추천 시점에 재고가 실제로 있었는지 여부
    created_at TIMESTAMP DEFAULT NOW()
);

-- 성과 보고용 집계 인덱스
CREATE INDEX idx_eff_saved_hours ON simulation_efficiency_logs (saved_hours);
```

# 설계의 타임트래블 UI 활용법

시간 축 고정: 모든 이벤트 테이블(risk, inventory)에 replay_timestamp를 두었습니다. Airflow가 데이터를 리플레이할 때 이 컬럼에 가상 시간을 찍어줍니다.

프론트엔드 연동: 사용자가 UI에서 시간을 2018년 5월 1일 14시로 옮기면, SELECT \* FROM ... WHERE replay_timestamp <= '2018-05-01 14:00:00' 쿼리로 그 시점까지의 모든 알림과 재고 변화를 한꺼번에 불러올 수 있습니다.

성과 가시화: simulation_efficiency_logs의 saved_hours를 모두 합산(SUM)하여 화면 상단에 **"현재까지 우리 시스템이 단축한 총 배송 시간: 4,200시간"**과 같은 지표를 실시간으로 띄울 수 있습니다.
