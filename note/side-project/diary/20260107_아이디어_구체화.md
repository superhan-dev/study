# 1. 핵심 목표 재정의 (데이터 기준)

- "어디서, 왜, 누구 때문에 배송이 늦어졌는가?"
- "누가 신뢰할 수 있는 판매자인가?"
- "이 조건에서 상품이 언제 도착할 가능성이 높은가?"

이를 위해 3가지 파생 데이터 계층을 구성합니다.

1. **Raw Data**
2. **Event / Fact Table**
3. **Analytics / Feature Table**

---

# 2. 1단계: Event / Fact Table 생성 (핵심)

## fact_order_delivery

주문 단위의 배송 이벤트 테이블입니다.

### 생성 기준

`orders` + `order_items` + `customers` + `sellers`

### 테이블 구조

```text
fact_order_delivery
-------------------
order_id
seller_id
customer_id
product_category

customer_state
customer_city
seller_state

order_purchase_ts
order_approved_ts
order_carrier_ts
order_delivered_ts
order_estimated_ts

is_delayed BOOLEAN
```

### 파생 컬럼 생성 규칙

- `is_delayed = order_delivered_ts > order_estimated_ts`

### Stage별 Latency 계산

이 프로젝트의 핵심 분석 지표입니다.

```text
payment_latency_hours = approved_ts - purchase_ts
seller_handling_latency_hours = carrier_ts - approved_ts
carrier_delivery_latency_hours = delivered_ts - carrier_ts
total_delivery_latency_hours = delivered_ts - purchase_ts
```

> 이를 통해 지연의 원인 제공자를 분해할 수 있습니다.

---

# 3. 2단계: 배송 병목 분석용 Analytics Table

## delivery_latency_by_dimension

차원별 병목 분석을 위한 테이블입니다.

### 분석 차원

- 지역
- 판매자
- 카테고리
- 날짜 (Day / Week)

### 예시 구조: delivery_latency_by_region

```text
customer_state
order_count
avg_total_latency
p90_total_latency
delay_rate
```

### 예시 구조: delivery_latency_by_seller

```text
seller_id
order_count
avg_seller_handling_latency
avg_carrier_latency
delay_rate
```

### 활용 방안

- "어느 지역의 배송이 느린가?"
- "어느 판매자가 출고를 지연시키는가?"
- 대시보드와 직접 연동 가능

---

# 4. 3단계: Seller Intelligence 데이터 생성

## seller_performance_features

판매자 평가를 위한 Feature 테이블입니다.

### Feature 목록

- `seller_id`
- `total_orders`
- `avg_total_delivery_hours`
- `avg_seller_handling_hours`
- `delay_rate`
- `avg_review_score`
- `on_time_delivery_rate`

### 리뷰 데이터 결합

- `avg_review_score = AVG(order_reviews.review_score)`

## Seller Reliability Score (계산 결과 테이블)

### seller_score

```text
seller_id
score
rank
```

### 점수 산출 예시 로직

```text
score = 0.4 * normalize(on_time_rate)
      - 0.3 * normalize(1 / avg_delivery_time)
      - 0.3 * normalize(avg_review_score)
```

> API 및 캐시 서버를 통해 서빙합니다.

---

# 5. 4단계: ETA 예측용 데이터

## delivery_eta_stats

예상 배송 시간을 제공하기 위한 통계 테이블입니다.

### Key 조합

`(seller_id, customer_state, product_category)`

### 컬럼

- `p50_delivery_hours`
- `p90_delivery_hours`
- `sample_count`

### 생성 방법

- `PERCENTILE_CONT(0.5) WITHIN GROUP`
- `PERCENTILE_CONT(0.9) WITHIN GROUP`

> 평균값이 아닌 분포 기반의 ETA를 제공합니다.

### API 활용 예시

```json
{
  "estimated_delivery": {
    "p50": "3.2 days",
    "p90": "5.1 days",
    "confidence": "HIGH"
  }
}
```

---

# 6. 5단계: 이상 탐지용 데이터

## delivery_anomaly_daily

일자별 이상 징후를 탐지합니다.

### 구조

- `date`
- `dimension_type` (REGION / SELLER)
- `dimension_id`
- `avg_latency`
- `baseline_latency`
- `z_score`
- `is_anomaly`

### 예시

- "SP 지역, 오늘 배송시간 전일 대비 +42% 증가"

> Kafka 및 Stream 처리 확장을 설명하기에 적합합니다.

---

# 7. 전체 데이터 흐름 요약

1. **CSV Raw Data**
2. **fact_order_delivery**
3. **Analytics Tables**
    - `latency_by_region`
    - `latency_by_seller`
    - `seller_features`
    - `eta_stats`
    - `anomaly_daily`
4. **Application**
    - API / Dashboard / Cache

---

# 8. 프로젝트의 백엔드 엔지니어링 가치

- 단순 CRUD가 아닌 데이터 모델링 중심의 설계
- 병목 분석, 추천, 예측 기능 포함
- Batch, Analytics, Cache 등 다양한 시스템 설계 가능
- Kafka 및 Stream 처리로의 확장 가능성 보유