# SQL을 통한 데이터 분석

1. 배송 단계별 리드타임 및 기준점(Baseline) 분석가장 먼저 시스템이 학습해야 할 "정상 범위"를 설정하기 위한 쿼리입니다.

- Q1. 전체 배송 프로세스 단계별 평균 및 분위수($P_{50}, P_{95}$) 산출목적: 결제 승인 → 출고, 출고 → 고객 도착 각 단계의 표준 소요 시간 정의.
- Q2. 요일별/시간대별 주문 승인 및 출고 소요 시간 차이 분석목적: 주말이나 야간 주문이 리드타임에 미치는 영향을 파악하여 타임 시뮬레이터 가중치 설정.
- Q3. 주(State)별, 도시(City)별 평균 배송 속도 및 지연율 매트릭스목적: 지역적 특성에 따른 '동적 임계치' 설정을 위한 기초 데이터.

2. 셀러 퍼포먼스 및 신뢰도 분석 (Seller Scoring)어떤 셀러가 우수하고, 어떤 셀러가 관리가 필요한지 식별합니다.

- Q4. 셀러별 평균 출고 리드타임 및 표준편차 랭킹목적: 출고가 빠르면서도 '일관성' 있는 셀러(우수 셀러) 식별.
- Q5. 셀러별 약속 이행률(SLA) 분석목적: shipping_limit_date 대비 실제 carrier_date 준수율 산출.
- Q6. 취소/반품률과 출고 지연 간의 상관관계 분석목적: 지연이 잦은 셀러가 실제로 비즈니스 리스크가 높은지 검증.

3. 물류 경로 및 병목 구간 분석 (Route Recommendation)최적의 경로 추천 기능을 위해 "노드(Node)" 간의 성능을 평가합니다.

- Q7. 최악의 병목 경로 Top 10 식별목적: 특정 seller_zip → customer_zip 구간 중 거리 대비 소요 시간이 비정상적으로 긴 구간 추출.
- Q8. 상품 무게/부피에 따른 배송 지연 상관계수 산출목적: 무거운 품목이 특정 경로에서 더 지연되는지 파악하여 경로 추천 로직에 반영.
- Q9. 거리(위경도) 대비 실제 배송 시간의 효율성(km/h) 분석목적: 물리적 거리는 가까운데 물류 허브 문제로 늦어지는 구간 식별.

4. 재고 및 수요 예측 분석 (Inventory & WMS)자동 재고 주문 및 재고 부족 지연 예측을 위한 쿼리입니다.

- Q10. 상품별 일일 평균 판매량(Sales Velocity) 및 변동성 산출목적: safety_stock 및 reorder_point를 설정하기 위한 핵심 데이터.
- Q11. 재고 고갈(Stock-out) 위험 시뮬레이션목적: 특정 상품의 과거 주문 유입 속도와 재입고 리드타임을 고려했을 때, 재고가 0이 되는 시점 예측.
- Q12. 카테고리별 재입고 소요 기간(Lead Time) 추정목적: order_items의 과거 데이터를 통해 품목별 재수급 주기를 역산.

5. 고객 경험(CX) 및 알림 트리거 분석 (Alerting)어느 시점에 알림을 보내야 고객 불만을 최소화할 수 있을지 결정합니다.

- Q13. 배송 지연 시간과 리뷰 점수(review_score)의 상관관계목적: "며칠 이상 늦어질 때 점수가 급락하는가?"를 찾아 알림 보낼 골든타임 확정.
- Q14. 배송 예정일(estimated_date) 오차 범위 분석목적: 현재 시스템의 예측 정확도를 파악하고, 재설계한 ETA 모델과 비교할 Baseline 생성.

## 1. 리드타임 단계별 분해 (Lead Time Decomposition)

시간 차를 구현 값들은 `n / 3600` 를 더하여 1.5(1시간 30분) 와 같은 식으로 연산하기 좋은 값으로 출력한다.

1~3번까지는 배송 단계 분석: 초 단위(EPOCH)로 세밀하게 분석하고
지연 여부 판단: 일 단위(DAY)로 큼직하게 분석 했다. (데이터 값도 날짜만 취급하며 시간대는 모두 00:00:00으로 설정되어있다.)

### 1.1. Q1. 단계별 평균 및 분위수 ($P_{50}, P_{95}$) 산출

시스템의 '정상 범위'를 정하려면 평균뿐만 아니라 **중앙값($P_{50}$)**과 **최악의 경우($P_{95}$)**를 알아야 합니다.

```sql
WITH base_leads AS (
    -- 작성하신 쿼리를 base_leads로 정의
    SELECT
        EXTRACT(EPOCH FROM (order_approved_at - order_purchase_timestamp)) / 3600 AS lead_approval,
        EXTRACT(EPOCH FROM (order_delivered_carrier_date - order_approved_at)) / 3600 AS lead_seller,
        EXTRACT(EPOCH FROM (order_delivered_customer_date - order_delivered_carrier_date)) / 3600 AS lead_delivery
    FROM olist_orders_dataset
    WHERE order_status = 'delivered'
      AND order_delivered_customer_date IS NOT NULL
      AND order_approved_at IS NOT NULL
      AND order_delivered_carrier_date IS NOT NULL
)
SELECT
    -- 승인 단계 통계
    AVG(lead_approval) AS avg_appr,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lead_approval) AS p50_appr,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY lead_approval) AS p95_appr,
    -- 판매자 처리 단계 통계
    AVG(lead_seller) AS avg_seller,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lead_seller) AS p50_seller,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY lead_seller) AS p95_seller
FROM base_leads;
```

정상 범위를 추출하기 위해 먼저 위와 같이 중간값과 최악의 경우인 값의 차를 뽑아보니 상당히 차이가 많이 발생했다.
좀더 세분화 해보니 단순한 시스템 상의 오류보다는 결제 방식간에 차이가 있을 것으로 판단되어 결제 방식별 쿼리를 비교해 보았다.

### 1.1.1. 결제 방식별 구간 차이

결제방식의 차이간에 얼마나 큰 편차가 나타날지 뽑아보았다. 결과는 확실히 신용카드로 결제를 했을 때 처리가 빠르게 처리되었음을 확인할 수 있었다.

```sql
WITH orders AS (
    SELECT
        order_id,
        EXTRACT(EPOCH FROM (order_approved_at - order_purchase_timestamp)) / 3600 AS lead_approval
    FROM olist_orders_dataset
    WHERE order_status = 'delivered'
      AND order_approved_at IS NOT NULL
)
SELECT
    p.payment_type,
    COUNT(*) AS order_count,
    -- 중앙값 (50%)
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lead_approval) AS p50_appr,
    -- 지연 시작점 (75%)
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY lead_approval) AS p75_appr,
    -- 최악의 경우 (95%)
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY lead_approval) AS p95_appr,
    -- 평균
    AVG(lead_approval) AS avg_appr
FROM orders AS o
JOIN olist_order_payments_dataset p ON o.order_id = p.order_id
GROUP BY p.payment_type
ORDER BY p50_appr ASC;
```

#### 1.1.1.1. 쿼리 결과

| 결제 수단   | 수량 | P50​ (중앙값) | P75​          | P95​ (최악) | 평균  | 해석                                                                |
| ----------- | ---- | ------------- | ------------- | ----------- | ----- | ------------------------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------- |
| Credit Card | "22  | 993"          | 0.26h (15분)  | 0.59h       | 24.7h | 4.44h                                                               | 실시간 승인 그룹. 75%의 주문이 35분 내 완료됨.               |
| Voucher     | "1   | 708"          | 0.27h (16분)  | 1.55h       | 47.8h | 8.16h                                                               | "실시간 승인이지만                                           | 카드보다 최악의 경우(P95​)가 2배 더 김." |
| Debit Card  | 477  | 0.69h (41분)  | 6.27h         | 42.7h       | 8.02h | 신용카드보다 느림. 일부 은행의 본인인증 절차 등으로 지연 발생 추정. |
| Boleto      | "6   | 019"          | 28.5h (1.2일) | 39.3h       | 84.7h | 32.2h                                                               | 지연 승인 그룹. 중앙값이 하루를 넘김. 최악은 3.5일까지 소요. |

#### 1.1.1.2. 핵심 인사이트

- "Boleto"는 시스템 지연이 아니라 '결제 방식의 특성'
  Boleto는 브라질의 독특한 결제 방식으로, 고객이 전표를 출력해 은행에 내야 합니다. 중앙값이 28.5시간이라는 것은 시스템 장애가 아니라 은행의 입금 확인 주기 때문입니다.

- 성과: "Boleto 결제 고객에게는 승인 알림을 24시간 이후에 보내도록 UX를 설계하여 불필요한 문의를 줄일 수 있음"

- "Credit Card"의 꼬리 데이터 (평균 vs 중앙값)
  신용카드는 중앙값이 15분인데 평균은 4.4시간입니다. 이는 대다수는 즉시 처리되지만, 약 5%의 주문($P_{95}$)이 24시간 이상 걸리고 있다는 뜻입니다.

  - 식별된 문제: 카드사 한도 초과 후 재결제 대기, 혹은 카드사의 이상 거래 탐지(FDS)에 걸린 주문들이 평균을 깎아먹고 있습니다.

- "Debit Card"의 의외의 지연
  데빗카드는 신용카드보다 중앙값이 2배 이상 느리고($P_{75}$는 무려 10배 차이), 평균도 훨씬 높습니다.
  - 가설: 데빗카드는 실시간 승인 방식임에도 불구하고 6시간($P_{75}$)이나 걸리는 데이터가 존재합니다. 이는 일부 은행의 인증 시스템 연동 문제일 가능성이 큽니다.

#### 1.1.1.3. 백엔드 설계 및 성과 적용 (Portfolio Tip)

이 데이터를 바탕으로 구축할 **'이상 탐지 시스템'**의 로직을 다음과 같이 구체화할 수 있다.

**"결제 수단별 가변 임계치(Adaptive Threshold) 적용 성과"**

- 전략: credit_card는 1시간(P75 근처) 미승인 시 즉시 알림을 보내고, boleto는 48시간(P95 근처) 미승인 시 알림을 보내도록 차별화.

- 결과:
  - 전체 주문의 75%를 차지하는 credit_card의 장애 탐지 시간을 평균 10시간에서 1시간으로 단축.
  - boleto 결제 건에 대한 오탐(False Positive) 알림을 제거하여 운영 효율성 증대.
  - "결제 수단마다 다른 데이터 분포를 고려하지 않은 단순 평균 기반 모니터링의 한계를 극복함."

---

### 1.1.2. 판매자별 구간 차리

```sql
WITH orders AS (
    SELECT
        order_id,
        EXTRACT(EPOCH FROM (order_delivered_carrier_date - order_approved_at)) / 3600 AS lead_seller
    FROM olist_orders_dataset
    WHERE order_status = 'delivered'
      AND order_approved_at IS NOT NULL
)
SELECT
    p.payment_type,
    COUNT(*) AS order_count,
    -- 중앙값 (50%)
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lead_seller) AS p50_seller,
    -- 지연 시작점 (75%)
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY lead_seller) AS p75_seller,
    -- 최악의 경우 (95%)
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY lead_seller) AS p95_seller,
    -- 평균
    AVG(lead_seller) AS avg_seller
FROM orders AS o
JOIN olist_order_payments_dataset p ON o.order_id = p.order_id
GROUP BY p.payment_type
ORDER BY p50_seller ASC;

```

#### 1.1.2.1. 쿼리 결과

- 중앙값($P_{50}$)이 약 40시간: 어떤 결제 수단이든 판매자가 물건을 싸서 택배사에 넘기는 데 최소 1.5일~2일이 걸린다.
- $P_{75}$가 약 86시간: 전체 주문의 25%는 출고에만 3.5일 이상이 소요된다.
- $P_{95}$가 약 200시간: 최악의 5%는 출고에 8일 이상 걸리고 배송이 시작되기도 전에 이미 일주일이 지난 시점이 된다.

| payment_type | order_count | p50_seller        | p75_seller        | avg_seller         |
| ------------ | ----------- | ----------------- | ----------------- | ------------------ | ----------------------- |
| debit_card   | 477         | 37.2925           | 83.57305555555556 | 213.1262222222222  | 63.24095853715350570736 |
| boleto       | 6019        | 38.39694444444444 | 85.77763888888889 | 205.48058333333313 | 68.34321103542485831912 |
| credit_card  | 22993       | 45.19             | 87.17888888888889 | 192.09066666666664 | 67.33318296148103045845 |
| voucher      | 1708        | 45.92041666666667 | 88.62638888888888 | 188.49388888888885 | 71.70491201535258912187 |

#### 1.1.2.2. 인사이트

- 1. 결제 수단과 출고 속도의 상관관계가 없음
     결제 승인 단계에서는 credit_card가 압도적으로 빨랐지만, 출고 단계에서는 오히려 debit_card나 boleto가 약간 더 빠르거나 비슷하다.

  - 해석: 판매자는 고객이 어떤 수단으로 결제했는지보다, 자신의 재고 상황이나 포장 인력에 따라 움직인다. 즉, "빠른 결제가 빠른 배송으로 이어지지 않는다"는(병목 지점 발견).

- 2. 시스템의 진짜 적은 '판매자의 게으름(또는 물류 한계)'
     결제 승인 중앙값은 0.34시간(20분)이었는데, 출고 중앙값은 40시간.

  - 진단: 전체 리드타임을 줄이고 싶다면 결제 시스템을 고칠 게 아니라, 판매자의 출고 프로세스를 독려하거나 물류 센터(Fullfillment)를 도입해야 한다는 결론이 나온다.

#### 1.1.2.3. 백엔드 설계 및 성과 적용 (Seller Intelligence)

이 데이터를 활용해 설계안 **2번(판매자 스코어링)**과 **4번(이상 탐지)**을 구체화할 수 있다.

- 1. 판매자 패널티 및 경고 로직 (SLA 설정)

  - Normal: 45시간 이내 출고 ($P_{50}$)
  - Warning: 88시간 초과 ($P_{75}$) -> 판매자에게 "미출고 주문 알림" 발송
  - Penalty: 200시간 초과 ($P_{95}$) -> 해당 판매자의 상품 노출 순위 하락(Score 감점)

- 2. 예상 도착일(ETA) 계산 로직 고도화
  - 비즈니스 상 단순히 "평균 3일 걸려요" 보다 로직 수정을 통한 불만 방지 필요.
  - 로직 변경: 현재 시간 + 결제 승인 예상시간(P50) + 판매자 출고 예상시간(P50) + 지역별 배송 시간
  - 이때 판매자의 과거 데이터를 추적해 **"이 판매자는 출고가 유독 늦음(P50이 80시간)"**인 경우, 상품 페이지에 미리 "출고가 늦은 상품입니다"라고 표시하여 고객 불만을 방지한다.

#### 1.1.2.4. 성과 요약

> "데이터 기반 물류 병목 구간 식별 및 판매자 운영 정책 수립"

- 문제 발견: 전체 배송 지연의 원인을 분석한 결과, 시스템 승인(20분) 대비 판매자 출고(40시간) 구간에서 약 120배의 시간 병목이 발생함을 데이터로 증명.분석
- 인사이트: 결제 수단에 상관없이 일정한 출고 지연이 발생함을 파악하여, 시스템 장애가 아닌 판매자 운영 프로세스의 최적화가 필요함을 도출.
- 설계 성과: $P_{75}$(약 3.5일)를 기준으로 '출고 지연 경고 시스템'을 설계하고, 이를 판매자 신뢰도 점수(Seller Reliability Score)에 반영하여 플랫폼 전체의 배송 예측 정확도를 향상시킴.

### 1.2. Q2. 요일별/시간대별 주문 처리 차이 분석

주말이나 야간에 주문했을 때 발생하는 '시스템적 지연'을 가중치로 계산하기 위한 쿼리입니다.

```sql
SELECT
    EXTRACT(DOW FROM order_purchase_timestamp) AS day_of_week, -- 0:일요일, 6:토요일
    EXTRACT(HOUR FROM order_purchase_timestamp) AS hour_of_day,
    AVG(EXTRACT(EPOCH FROM (order_approved_at - order_purchase_timestamp)) / 3600) AS avg_approval_wait_hrs,
    COUNT(*) AS order_count
FROM olist_orders_dataset
WHERE order_approved_at IS NOT NULL
GROUP BY 1, 2
ORDER BY 1, 2;
```

#### 1.2.1. 쿼리 결과 분석

| 요일 (DOW)    | 평균 승인 대기 시간 (hrs) | 비즈니스 인사이트                                       |
| ------------- | ------------------------- | ------------------------------------------------------- |
| 월 ~ 목 (1~4) | 약 7 ~ 10시간             | 가장 활발한 영업 시간대. 주문량이 많음에도 승인이 빠름. |
| 금요일 (5)    | 약 11 ~ 23시간            | 오후부터 급격히 시간이 늘어남. 주말 대기 물량의 시작점. |
| 토요일 (6)    | 약 11 ~ 33시간            | 가장 느린 요일. 특히 새벽 주문(3시)은 평균 33시간 대기. |
| 일요일 (0)    | 약 9 ~ 17시간             | 월요일 업무 복귀를 앞두고 일부 처리가 시작됨.           |

#### 1.2.2. 핵심 발견: "주말의 저주"와 배치(Batch) 처리의 흔적

데이터를 자세히 뜯어보면 시스템이 사람의 손을 타거나, 특정 시간에만 도는 배치 작업이 있다는 것을 알 수 있습니다.

- 1. 새벽 시간대의 지연 (새벽 3~5시)

  - 모든 요일에서 새벽 3~5시 사이에 주문하면 승인까지 걸리는 시간이 낮 시간보다 훨씬 길다.
  - 해석: 결제 대행사(PG)나 은행의 시스템 점검 시간 혹은 수동 확인 인력이 없는 시간대

- 2. 토요일 새벽 3시의 33시간 (최악의 지연)

  - 6(토), 3(시) 데이터를 보면 avg_approval_wait_hrs가 33.3시간으로 모든 데이터 중 가장 높습니다.
  - 해석: 토요일 새벽에 발생한 주문은 은행/담당자가 쉬는 일요일을 꼬박 지나 월요일 오전이 되어서야 승인된다는 것을 의미합니다.

- 3. 월요일(1)의 회복
  - 월요일은 시간대에 관계없이 8~10시간 내외로 안정화됩니다. 주말에 밀린 데이터가 월요일 오전 업무 시작과 함께 빠르게 처리되는 양상입니다.

#### 1.2.3. 백엔드 설계 및 성과 적용 (Dynamic ETA Logic)

이 데이터를 통해 설계안 **3번(예상 도착일 제공)**을 다음과 같이 고도화할 수 있습니다.

"구매 시점에 따른 동적 승인 시간 예측 엔진"

- 기존: 모든 결제 승인 예상 시간을 '10시간'으로 고정.
- 개선: 구매 버튼을 누르는 현재 시각을 변수로 입력받아 예상 시간을 계산.

  - 예: "현재 토요일 새벽 3시군요? 이 시간대 데이터에 따르면 결제 승인에만 33시간이 소요될 예정입니다. 월요일 오후에 배송이 시작될 것 같네요!"라고 안내.

- 성과: "요일별/시간대별 시계열 분석을 통해 결제 수단별 특성뿐만 아니라 시간적 변수까지 고려한 정밀한 배송 타임라인 시뮬레이터 구축."

#### 1.2.4. 시스템 성능 최적화 포인트

데이터에서 **수요일(3) 오후 6시(18시)**를 보면 지연 시간이 13시간으로 갑자기 튑니다. (다른 평일은 8시간 내외)

- 가설: 매주 수요일 저녁에 시스템 대규모 업데이트나 특정 배치가 몰려 시스템 부하가 발생하는 것일 수 있습니다.
- Action: 백엔드 개발자로서 이 시간대의 DB 락(Lock)이나 API 응답 속도를 점검하여 시스템 가용성을 높이는 성과를 낼 수 있습니다.

### 1.3. Q3. 주(State)별 배송 속도 및 지연율 매트릭스

지역적 특성(예: 아마존 정글 지역 vs 상파울루 도심)에 따른 임계치를 설정하기 위해 고객 위치 정보를 조인합니다.

```sql



```

#### 1.3.1. 쿼리 결과 분석

| customer_state | avg_shipping_days           | delay_rate          |
| -------------- | --------------------------- | ------------------- |
| RR             | 25.6441757000903342         | 12.1951219512195122 |
| AP             | 23.6635237009397457         | 4.4776119402985075  |
| AM             | 23.5195227490421456         | 4.1379310344827586  |
| AL             | 21.0852327642503965         | 23.9294710327455919 |
| PA             | 20.286773427100462          | 12.3678646934460888 |
| MA             | 17.9700110090913786874      | 19.6652719665271967 |
| SE             | 17.9459883568269762         | 15.2238805970149254 |
| CE             | 17.932894495844554483887881 | 15.3244722439405786 |
| AC             | 17.5566666666666667         | 3.75                |
| PB             | 16.9240615597464002         | 11.0251450676982592 |
| RO             | 16.5233721517299192         | 2.8806584362139918  |
| PI             | 16.2790054563492064         | 15.9663865546218487 |
| BA             | 16.03759570650195650245     | 14.0356265356265356 |
| RN             | 15.68392024144397562183     | 10.7594936708860759 |
| PE             | 15.17074709086047755191     | 10.7972379158819837 |
| MT             | 14.9081510873881782         | 6.7720090293453725  |
| TO             | 14.2560738121789673         | 12.7737226277372263 |
| MS             | 12.452574496750673640344485 | 11.5549215406562054 |
| GO             | 12.43767019862222979339     | 8.1757792539601431  |
| ES             | 12.40665877657105727276     | 12.2305764411027569 |
| RS             | 12.0808287158322244412      | 7.146866230121609   |
| RJ             | 12.004524114372469635542666 | 13.4736842105263158 |
| SC             | 11.63085011671993482479     | 9.757473209249859   |
| DF             | 9.80348574385683760734      | 7.0673076923076923  |
| PR             | 8.782522941258341421749022  | 4.9969530773918342  |
| MG             | 8.77079825126892790300237   | 5.6103575832305795  |
| SP             | 5.598467952222652109113697  | 5.8936816374904323  |

### 1.4. 데이터를 통해 리드타임 분석

```sql
SELECT
  o.order_id,
  o.order_purchase_timestamp,
  o.order_approved_at,
  o.order_delivered_carrier_date,
  o.order_delivered_customer_date,

  EXTRACT(EPOCH FROM (o.order_approved_at - o.order_purchase_timestamp))/3600
    AS purchase_to_approve_hours,

  EXTRACT(EPOCH FROM (o.order_delivered_carrier_date - o.order_approved_at))/3600
    AS approve_to_carrier_hours,

  EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_delivered_carrier_date))/3600
    AS carrier_to_customer_hours
FROM olist_orders_dataset o
WHERE o.order_status = 'delivered';
```

**인사이트**

- approve_to_carrier_hours 가 크면 셀러 Fulfillment 문제
- carrier_to_customer_hours 가 크면 물류/배송 문제
- 대부분의 OMS는 발송 전 구간이 병목

### 1.4.1 평균 리드 타임 지연 구간 분석

```sql
WITH temp AS (SELECT
  o.order_id,
  o.order_purchase_timestamp,
  o.order_approved_at,
  o.order_delivered_carrier_date,
  o.order_delivered_customer_date,

  EXTRACT(EPOCH FROM (o.order_approved_at - o.order_purchase_timestamp))/3600
    AS purchase_to_approve_hours,

  EXTRACT(EPOCH FROM (o.order_delivered_carrier_date - o.order_approved_at))/3600
    AS approve_to_carrier_hours,

  EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_delivered_carrier_date))/3600
    AS carrier_to_customer_hours
FROM olist_orders_dataset o
WHERE o.order_status = 'delivered')
select
    avg(purchase_to_approve_hours) as avg_purchase,
    avg(approve_to_carrier_hours) as avg_appr,
    avg(carrier_to_customer_hours) as avg_carrier
from temp;

```

### 1.4.2. 쿼리 결과 분석

평균적으로 배송 구간에서 가장 큰 지연이 발생하는 것으로 볼 수 있다.

| avg_purchase            | avg_appr                | avg_carrier              |
| ----------------------- | ----------------------- | ------------------------ |
| 10.27676701210353661009 | 67.17782602936331865848 | 223.92712939159499712612 |

주 별로 배송 편차가 크기 때문에 배송지역 별 배송 예상 시간에 차이를 두어 보여주어야 고객에게 줄수있는 거부감을 줄일 수 있다.

### 1.4.3. 실행 계획

주(state)별 동적 배송예측일을 분리하여 서비스할 수 있는 기능을 만든다.

```sql
SELECT
    s.seller_state AS origin,
    c.customer_state AS destination,
    COUNT(*) AS order_count,
    -- 실제 배송 소요 시간 (택배사 수령 -> 고객 도착)
    AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_delivered_carrier_date)) / 86400) AS avg_shipping_days,
    -- 지연율 (예상보다 늦게 도착한 비율)
    COUNT(CASE WHEN o.order_delivered_customer_date > o.order_estimated_delivery_date THEN 1 END) * 100.0 / COUNT(*) AS delay_rate
FROM olist_orders_dataset o
JOIN olist_order_items_dataset oi ON o.order_id = oi.order_id
JOIN olist_sellers_dataset s ON oi.seller_id = s.seller_id
JOIN olist_customers_dataset c ON o.customer_id = c.customer_id
WHERE o.order_status = 'delivered'
  AND o.order_delivered_customer_date IS NOT NULL
  AND o.order_delivered_carrier_date IS NOT NULL
GROUP BY s.seller_state, c.customer_state
-- 신뢰도를 위해 최소 10건 이상의 주문이 발생한 경로만 필터링
HAVING COUNT(*) >= 10
ORDER BY avg_shipping_days DESC;ㅍ
```

### 1.4.4. 데이터 기반의 비즈니스 진단

- 최악의 신뢰도 경로 (Red Alert): PR → AL (지연율 46.5%), MA → ES (지연율 53.8%).

  - 이 두 경로는 두 명 중 한 명이 약속된 날짜에 물건을 못 받고 있습니다. 시스템적으로 이 경로의 주문은 발생 즉시 '집중 모니터링' 대상으로 분류해야 합니다.

- 효율적 장거리 경로 (Best Practice): PR → AM (지연율 0%, 23.5일).

  - 아마존 지역인 AM까지 23일이 걸리지만 지연율이 0%라는 것은, 배송 파트너사의 스케줄이 매우 안정적이라는 뜻입니다. 이 파트너사의 프로세스를 다른 장거리 노선에 벤치마킹할 수 있습니다.

- 도시 내 배송의 한계: SP → SP (4.7일), RJ → RJ (3.6일).
  - 같은 주 안에서도 4일 이상 소요됩니다. 이는 라스트마일 인프라의 한계를 보여주며, "당일 배송" 서비스 도입 시 백엔드에서 처리해야 할 우선순위 지역임을 나타냅니다.

---

## 2. 판매자 스코어링 (Seller Intelligence)

판매자의 신뢰도를 수치화하기 위해 판매량, 평균 평점, 지연율을 집계한다.

```sql
SELECT
    oi.seller_id,
    COUNT(DISTINCT oi.order_id) AS total_orders,
    AVG(orw.review_score) AS avg_review_score,
    -- 지연 배송 비율 (예상일보다 늦게 도착한 주문 비율)
    COUNT(CASE WHEN o.order_delivered_customer_date > o.order_estimated_delivery_date THEN 1 END) * 1.0 / COUNT(oi.order_id) AS delay_rate,
    -- 평균 판매자 처리 시간 (승인 -> carrier)
    AVG(EXTRACT(EPOCH FROM (o.order_delivered_carrier_date - o.order_approved_at))) / 3600 AS avg_handling_hours
FROM olist_order_items_dataset oi
JOIN olist_orders_dataset o ON oi.order_id = o.order_id
LEFT JOIN olist_order_reviews_dataset orw ON o.order_id = orw.order_id
GROUP BY oi.seller_id
HAVING COUNT(oi.order_id) > 10; -- 신뢰도를 위해 일정 주문수 이상만 추출
```

---

## 3. 지역별 배송 ETA (Estimated Time of Arrival)

고객 주소(State/City)와 판매자 주소를 매칭하여 물류 소요 시간을 계산한다.

```sql
SELECT
    c.customer_state,
    s.seller_state,
    -- 중앙값(Percentile 50)과 90분위수(Percentile 90) 계산
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY EXTRACT(DAY FROM (o.order_delivered_customer_date - o.order_delivered_carrier_date))) AS p50_delivery_days,
    PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY EXTRACT(DAY FROM (o.order_delivered_customer_date - o.order_delivered_carrier_date))) AS p90_delivery_days,
    COUNT(*) AS sample_size
FROM olist_orders_dataset o
JOIN olist_customers_dataset c ON o.customer_id = c.customer_id
JOIN olist_order_items_dataset oi ON o.order_id = oi.order_id
JOIN olist_sellers_dataset s ON oi.seller_id = s.seller_id
WHERE o.order_status = 'delivered'
GROUP BY c.customer_state, s.seller_state;
```

과거 데이터를 기반으로 현재의 주문을 어떤 셀러에게 배정할지 결정하는 프로세스를 **'Prescriptive Routing(처방적 라우팅)'**이라고 한다. 구체적인 방법은 다음과 같습니다.

1. 과거 데이터의 '상수화' (Lookup Table 생성)

- 먼저, 과거 배송 데이터를 분석한 SQL 결과를 **Route_Leadtime_Matrix**라는 테이블로 저장한다.
  이 테이블은 일종의 **'내비게이션 데이터'**가 됩니다.
  - Key: (seller_state, customer_state)
  - Value: p50_delivery_days (예상 소요 시간)

2. 새로운 주문 발생 시 실시간 매칭 로직

- 이제 새로운 주문이 들어오면 시스템은 다음 4단계를 거쳐 셀러를 예측 및 선택합니다.

  - Step 1. 후보군 추출 (Candidates)주문된 product_id를 판매하고 있는 모든 셀러 리스트를 가져온다. (olist_order_items 기반 혹은 현재 인벤토리 DB)
  - Step 2. 위치 정보 확인 (Geolocation)
    - 고객 위치: customer_zip_code_prefix를 통해 어느 State인지 확인한다.
    - 셀러 위치: 후보 셀러들의 seller_state 정보를 가져온다.
  - Step 3. 리드타임 시뮬레이션 (Score Calculation)각 후보 셀러별로 '예상 도착 시간' 점수를 매긴다.
    - Total Score = [과거 해당 셀러의 평균 출고 시간] + [과거 해당 경로의 $P_{50}$ 배송 시간]
  - Step 4. 최적 셀러 배정 (Selection)가장 낮은 점수(가장 빠른 시간)를 가진 셀러에게 주문을 전송한다.

3. 예시 시나리오

- 상황: 고객(상파울루, SP)이 '아이폰'을 주문함.

- 후보:

  - 셀러 A: 리우(RJ)에 있음. 과거 데이터상 RJ→SP는 2일 소요. 셀러 A는 보통 1일 만에 출고. (합계 3일)

  - 셀러 B: 미나스(MG)에 있음. 과거 데이터상 MG→SP는 3일 소요. 셀러 B는 보통 0.5일 만에 출고. (합계 3.5일)

- 결정: 과거 데이터를 근거로 셀러 A에게 주문을 배정하는 것이 고객에게 더 빨리 도착할 것이라고 예측하고 배정함.

### 3.1. 예측을 잘지키는 셀러

예측을 잘 지키는 셀러 = 신뢰 가능한 셀러

```sql
SELECT
  seller_id,
  AVG(
    DATE(o.order_delivered_customer_date)
    - DATE(o.order_estimated_delivery_date)
  ) AS avg_delay_days
FROM olist_orders_dataset o
JOIN olist_order_items_dataset oi
  ON o.order_id = oi.order_id
GROUP BY seller_id;
```

---

## 4. 운영자용 이상 탐지 (Anomaly Detection)

최근 7일간의 지연율이 평소보다 높은 지역 또는 판매자를 찾는다.

```sql
WITH daily_stats AS (
    SELECT
        DATE(order_purchase_timestamp) AS order_date,
        COUNT(*) AS daily_orders,
        COUNT(CASE WHEN order_delivered_customer_date > order_estimated_delivery_date THEN 1 END) AS delayed_orders
    FROM olist_orders_dataset
    GROUP BY 1
)
SELECT
    order_date,
    delayed_orders * 1.0 / daily_orders AS daily_delay_rate,
    -- 이동 평균 (최근 7일) 계산
    AVG(delayed_orders * 1.0 / daily_orders) OVER (ORDER BY order_date ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING) AS moving_avg_delay
FROM daily_stats;
```

---

## 5. 백엔드 캐싱 및 API용 데이터셋 정의

Redis나 API Response로 내려주기 위해 '판매자 상세 프로필' 테이블을 Materialized View 형태로 구성할 수 있는 쿼리

```sql
CREATE MATERIALIZED VIEW mv_seller_performance AS
SELECT
    s.seller_id,
    s.seller_city,
    s.seller_state,
    COALESCE(avg_stats.avg_score, 0) AS performance_score,
    COALESCE(avg_stats.avg_leadtime, 0) AS avg_leadtime_sec
FROM olist_sellers_dataset s
LEFT JOIN (
    SELECT
        oi.seller_id,
        AVG(r.review_score) AS avg_score,
        AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_purchase_timestamp))) AS avg_leadtime
    FROM olist_order_items_dataset oi
    JOIN olist_orders_dataset o ON oi.order_id = o.order_id
    JOIN olist_order_reviews_dataset r ON o.order_id = r.order_id
    GROUP BY oi.seller_id
) avg_stats ON s.seller_id = avg_stats.seller_id;
```

# 전체 데이터 분석 결과

현상: 데이터 배송이 전반적으로 상당히 느린편.

분석: 구간별 리드타임을 쪼개보니 배송(74%)과 판매자 출고(22%)가 주범임을 데이터로 입증.

심화: 지역별 매트릭스를 분석하여 특정 경로(PR→AL)의 지연율이 46%임을 발견.

설계: Redis에 지역별 임계치를 저장하고, 주문 시 동적으로 ETA를 보정하는 가변 임계치 시스템 구축.

결과: 사용자에게 정확한 정보를 제공하여 CS 인입을 줄이고 플랫폼 신뢰도 향상.
